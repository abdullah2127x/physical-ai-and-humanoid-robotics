# Chapter 1: ROS 2 Nodes, Topics, and Services — Content Implementation Tasks

**Generated by:** chapter-planner v2.0.0
**Source Plan:** chapter-01-plan.md
**Created:** 2025-12-16
**Status:** Ready for content-implementer

---

## Implementation Overview

This document provides the content-implementer with a complete checklist for creating Chapter 1 lesson materials. Each lesson includes lesson file creation, code examples, diagrams, exercises, and validation steps.

---

## Lesson 1: Introduction to ROS 2 Nodes

### Lesson File Creation
- [ ] Create `01-lesson-1.md` in content delivery location
  - Include: Learning objective, opening narrative, manual walkthrough, practice exercises
  - Structure: Show-then-explain pattern (working example first, then explanation)
  - Target audience: B1 beginners, no robotics experience assumed

### Code Examples

**Example 1.1.1: Minimal ROS 2 Node**
- [ ] Create `minimal_node.py` — 15-line node that prints "Hello Robot" every 1 second
  - File structure:
    ```python
    import rclpy
    from rclpy.node import Node

    class MinimalNode(Node):
        def __init__(self):
            super().__init__('minimal_node')
            self.timer = self.create_timer(1.0, self.timer_callback)

        def timer_callback(self):
            self.get_logger().info('Hello Robot')

    def main(args=None):
        rclpy.init(args=args)
        node = MinimalNode()
        rclpy.spin(node)
        rclpy.shutdown()

    if __name__ == '__main__':
        main()
    ```
  - Tests: Verify runs without error, prints message every 1 second
  - Documentation: Line-by-line explanation in lesson text

**Example 1.1.2: Node with Modifiable Parameters**
- [ ] Create `configurable_node.py` — same node, but message and frequency configurable
  - Features: Accept command-line parameters for message text and frequency
  - Tests: Verify frequency changes work, message text changes work

### Diagrams/Visuals

- [ ] Create diagram: "ROS 2 Node Anatomy"
  - Show: Node box, timer callback, logger, init, spin
  - Label each part: what it does, why it matters
  - Format: PNG or SVG, embedded in lesson markdown

- [ ] Create diagram: "Node Lifecycle"
  - Show: rclpy.init() → Node creation → rclpy.spin() → rclpy.shutdown()
  - Include: State transitions, when each happens

### Exercises

**Exercise 1.1a: Create Minimal Node from Scratch**
- [ ] Task description: Students create minimal_node.py without copy-paste
  - Scaffolding: Provide step-by-step outline, not code
  - Success criteria:
    - [ ] Node starts without errors
    - [ ] Prints "Hello Robot" to console
    - [ ] Student can stop node with Ctrl+C
  - Estimated time: 15 minutes
  - Solution file: `solutions/01-lesson-1-exercise-1a.py`

**Exercise 1.1b: Modify Node Behavior**
- [ ] Task description: Change message and frequency from Lesson 1 node
  - Modifications requested:
    - [ ] Change message from "Hello Robot" to "Hello ROS"
    - [ ] Change timer frequency from 1.0 to 0.5 seconds (twice as fast)
  - Success criteria:
    - [ ] Message text changed
    - [ ] Frequency changed (messages appear twice per second)
  - Estimated time: 10 minutes
  - Solution file: `solutions/01-lesson-1-exercise-1b.py`

### Prerequisites Verification

- [ ] Checklist for students:
  - [ ] Python 3.10+ installed (verify with `python3 --version`)
  - [ ] ROS 2 Humble installed (verify with `ros2 topic list`)
  - [ ] Basic Python knowledge (can write simple function)
  - [ ] Linux command line familiarity

### Success Criteria

- [ ] By end of Lesson 1, students can:
  - [ ] Create minimal ROS 2 node from scratch
  - [ ] Modify node message and timer frequency
  - [ ] Explain what rclpy.spin() does (keeps node alive)
  - [ ] Explain what timer callback is (function called regularly)

---

## Lesson 2: Topics and Pub/Sub

### Lesson File Creation
- [ ] Create `02-lesson-2.md`
  - Include: Topic concepts, publisher example, subscriber example, pub/sub pattern
  - Narrative: "Nerve pathways" metaphor (topics as communication channels)

### Code Examples

**Example 2.1: Temperature Publisher**
- [ ] Create `temperature_publisher.py` — publishes temperature readings
  - Imports: `String` from std_msgs.msg
  - Creates: Publisher on topic `/temperature`
  - Publishes: "temperature: {value}°C" every 1 second
  - Simulates: Temperature increasing from 20 to 50°C
  - Tests:
    - [ ] Verify node starts
    - [ ] Verify messages appear in logs
    - [ ] Verify message format correct

**Example 2.2: Temperature Subscriber**
- [ ] Create `temperature_subscriber.py` — subscribes to temperature topic
  - Imports: `String` from std_msgs.msg
  - Creates: Subscriber on topic `/temperature`
  - Callback: Prints "Received temperature: {value}"
  - Tests:
    - [ ] Verify subscribes without error
    - [ ] Verify callback fires when publisher sends message

**Example 2.3: JSON Message Example**
- [ ] Create `temperature_json_publisher.py` — publishes JSON formatted message
  - Content: `{"temperature": 25, "unit": "C", "timestamp": 1703065200}`
  - Demonstrates: Complex data in string messages
  - Tests: Subscriber can parse JSON and extract values

### Diagrams/Visuals

- [ ] Create diagram: "Pub/Sub Pattern"
  - Show: Publisher box → Topic (named channel) → Subscriber box
  - Illustrate: Multiple publishers/subscribers on same topic possible
  - Key concept: Loose coupling (publisher doesn't know about subscriber)

- [ ] Create diagram: "Message Flow"
  - Show: Message creation → publish() → ROS 2 network → callback → received
  - Annotate: Each step with timing, order

- [ ] Create comparison table: "Topic vs Direct Connection"
  - Topic: Decoupled, many-to-many, asynchronous
  - Direct: Coupled, one-to-one, tight

### Exercises

**Exercise 2.1a: Create Temperature Publisher**
- [ ] Task: Build publisher node from scratch
  - Scaffolding provided: Node template (from Lesson 1)
  - Students add: Publisher creation, timer callback with publish
  - Success criteria:
    - [ ] Publisher created without errors
    - [ ] Messages published every 1 second
    - [ ] Message format correct: "temperature: {X}°C"
  - Estimated time: 20 minutes
  - Solution: `solutions/02-lesson-2-exercise-1a.py`

**Exercise 2.1b: Create Temperature Subscriber**
- [ ] Task: Build subscriber node from scratch
  - Scaffolding: Node template
  - Students add: Subscriber creation, callback function with print
  - Success criteria:
    - [ ] Subscriber created without errors
    - [ ] Callback receives messages
    - [ ] Messages printed to terminal
  - Estimated time: 20 minutes
  - Solution: `solutions/02-lesson-2-exercise-1b.py`

**Exercise 2.1c: Run Publisher and Subscriber Together**
- [ ] Task: Execute both nodes, verify communication
  - Instructions: Open 2 terminals, start publisher in one, subscriber in other
  - Success criteria:
    - [ ] Messages flow from publisher to subscriber
    - [ ] Subscriber displays 3+ consecutive messages
    - [ ] No errors or warnings
  - Estimated time: 10 minutes
  - Debugging guide: Troubleshoot topic name mismatches

**Exercise 2.2: Modify Message Content**
- [ ] Task: Extend publisher to send JSON with timestamp
  - Modify: Publisher sends `{"temperature": X, "timestamp": Y}` as JSON
  - Modify: Subscriber parses JSON and displays formatted output
  - Success criteria:
    - [ ] Publisher sends valid JSON
    - [ ] Subscriber parses without errors
    - [ ] Output formatted nicely (e.g., "Temp: 25C at 12:34:56")
  - Estimated time: 20 minutes
  - Solution: `solutions/02-lesson-2-exercise-2.py`

### Prerequisites Verification

- [ ] Completion of Lesson 1 (node structure knowledge)
- [ ] Understanding of Python classes and methods
- [ ] Ability to read and interpret Python function signatures

### Success Criteria

- [ ] By end of Lesson 2, students can:
  - [ ] Explain topic as "named bus" for communication
  - [ ] Create publisher manually (no copy-paste)
  - [ ] Create subscriber manually (no copy-paste)
  - [ ] Identify why pub/sub is "loosely coupled"
  - [ ] Trace message from publisher.publish() to subscriber callback

---

## Lesson 3: Debugging Pub/Sub with ROS 2 CLI Tools

### Lesson File Creation
- [ ] Create `03-lesson-3.md`
  - Include: CLI tools (ros2 topic, ros2 node, ros2 echo), debugging workflow
  - Narrative: "Detective skills" — inspecting running systems

### Code Examples

**Example 3.1: Broken Publisher (Intentional)**
- [ ] Create `broken_publisher.py` — publisher with bug (wrong topic name)
  - Bug: Publishes to `/temperature_wrong` instead of `/temperature`
  - Demonstrates: How to diagnose with CLI tools
  - Tests: Verify ros2 topic list shows `/temperature_wrong`

**Example 3.2: Broken Subscriber (Intentional)**
- [ ] Create `broken_subscriber.py` — subscriber listening to wrong topic
  - Bug: Subscribes to `/temperature_wrong` (won't receive from `/temperature`)
  - Demonstrates: Diagnosis with ros2 topic echo

**Example 3.3: Delayed Callback**
- [ ] Create `slow_subscriber.py` — callback takes 2 seconds to process
  - Demonstrates: Latency issues, slow processing
  - Shows: `ros2 topic hz` measuring actual publish rate vs processing rate

### Diagrams/Visuals

- [ ] Create diagram: "ROS 2 System Introspection"
  - Show: ros2 topic list → ros2 topic info → ros2 topic echo → ros2 node info
  - Each tool reveals different information

- [ ] Create flowchart: "Debugging Pub/Sub Checklist"
  - Q: Is topic created? (ros2 topic list)
  - Q: Are messages flowing? (ros2 topic echo)
  - Q: Is frequency correct? (ros2 topic hz)
  - Q: Is node running? (ros2 node list)

### Exercises

**Exercise 3.1a: Diagnose Broken Publisher**
- [ ] Task: Use CLI to find bug in broken_publisher.py
  - Given: Broken publisher running (student doesn't see code)
  - Tools provided: ros2 topic list, ros2 topic echo
  - Success criteria:
    - [ ] Student identifies wrong topic name using ros2 topic list
    - [ ] Student verifies no messages on expected `/temperature` topic
    - [ ] Student explains diagnosis steps
  - Estimated time: 15 minutes
  - Hint provided: "Check ros2 topic list for all topics"

**Exercise 3.1b: Diagnose Broken Subscriber**
- [ ] Task: Fix subscriber listening to wrong topic
  - Given: Publisher on `/temperature`, subscriber on `/temperature_wrong`
  - Tools: ros2 topic echo, ros2 node info
  - Success criteria:
    - [ ] Student diagnoses mismatch
    - [ ] Student fixes subscriber to listen to correct topic
    - [ ] Publisher-subscriber communication works
  - Estimated time: 15 minutes

**Exercise 3.2: Measure Message Frequency**
- [ ] Task: Use ros2 topic hz to measure publisher frequency
  - Given: Publisher running from Lesson 2
  - Instruction: Run `ros2 topic hz /temperature`
  - Success criteria:
    - [ ] Student runs command correctly
    - [ ] Student interprets output (e.g., "average rate: 1.0 Hz")
    - [ ] Student understands: 1.0 Hz = 1 message per second
  - Estimated time: 10 minutes

**Exercise 3.3: Three Roles Debugging Scenario**
- [ ] Task: Run deliberate multi-step debugging with AI guidance (Layer 2)
  - Scenario: Complex broken system (mix of issues)
  - Steps: List → Echo → Hz → Node Info → Diagnose
  - AI guidance provided at each step showing Teacher role
  - Success criteria:
    - [ ] Student follows systematic debugging approach
    - [ ] Student identifies root cause
    - [ ] Student explains what each CLI tool revealed
  - Estimated time: 20 minutes

### Prerequisites Verification

- [ ] Lessons 1-2 complete (working pub/sub code)
- [ ] Linux command line familiarity (running commands)
- [ ] Understanding of ROS 2 node and topic concepts

### Success Criteria

- [ ] By end of Lesson 3, students can:
  - [ ] Run ros2 topic list and understand output
  - [ ] Run ros2 topic echo and see live messages
  - [ ] Run ros2 topic hz and interpret frequency
  - [ ] Run ros2 node info and understand node details
  - [ ] Diagnose "no messages flowing" problems systematically

---

## Lesson 4: Services (Synchronous Request-Response)

### Lesson File Creation
- [ ] Create `04-lesson-4.md`
  - Include: Service concepts, .srv file format, server implementation, client implementation
  - Narrative: "Doorbell analogy" — ring, wait, get response

### Code Examples

**Example 4.1: Battery Status Service Definition**
- [ ] Create `Battery.srv` service definition file
  - Content:
    ```
    ---
    int32 percentage
    string status
    int32 timestamp
    ```
  - Explanation: Request (empty), Response (percentage, status, timestamp)
  - Tests: Verify file format correct

**Example 4.2: Battery Service Server**
- [ ] Create `battery_service_server.py` — service that returns battery status
  - Creates: Service server on `/robot/battery_status`
  - Callback: Simulates battery declining (100% → 0%)
  - Returns: Battery percentage, status ("charging"/"discharging"), timestamp
  - Tests:
    - [ ] Service starts without error
    - [ ] Service responds to client requests
    - [ ] Response format matches .srv definition

**Example 4.3: Battery Service Client**
- [ ] Create `battery_service_client.py` — calls battery service
  - Calls: `/robot/battery_status` service
  - Waits: For response (blocking)
  - Prints: "Battery: 85% - Discharging"
  - Includes: Timeout handling (try/except)
  - Tests:
    - [ ] Client calls service successfully
    - [ ] Response received and printed
    - [ ] Timeout handling works (if server slow)

**Example 4.4: Service with Error Handling**
- [ ] Create `battery_service_client_robust.py` — client with timeout
  - Features: Catches timeout exception, retry logic
  - Demonstrates: Error handling in synchronous calls
  - Tests: Intentionally delay server response, verify timeout works

### Diagrams/Visuals

- [ ] Create diagram: "Topic vs Service"
  - Topic (pub/sub): Asynchronous, publisher → topic → subscriber (no wait)
  - Service: Synchronous, client → service → response (blocking)
  - Use cases for each

- [ ] Create diagram: ".srv File Structure"
  - Request part (top), Response part (bottom), separator (---)
  - Example: Battery.srv with fields labeled

- [ ] Create diagram: "Service Call Sequence"
  - Timeline: Client calls → Server processes → Response sent → Client receives
  - Show: Blocking behavior (client waits)

### Exercises

**Exercise 4.1: Create Service Definition**
- [ ] Task: Write Battery.srv service file from scratch
  - Request: Empty (no input needed for battery query)
  - Response: 3 fields (percentage, status, timestamp)
  - Success criteria:
    - [ ] .srv file format correct (Request/Response/---)
    - [ ] File readable by ROS 2 (ros2 service type /service_name)
    - [ ] Fields have correct types
  - Estimated time: 10 minutes
  - Solution: `solutions/04-lesson-4-exercise-1.srv`

**Exercise 4.2: Implement Service Server**
- [ ] Task: Create battery_service_server.py from scratch
  - Server implementation: create_service() call, callback function
  - Callback: Builds response with battery%, status, timestamp
  - Success criteria:
    - [ ] Server starts and advertises service
    - [ ] Service responds to client requests
    - [ ] Response contains correct values
  - Estimated time: 20 minutes
  - Solution: `solutions/04-lesson-4-exercise-2.py`

**Exercise 4.3: Implement Service Client**
- [ ] Task: Create battery_service_client.py
  - Client implementation: create_client() call, wait for service, call it
  - Blocking behavior: Client waits for response
  - Success criteria:
    - [ ] Client connects to service
    - [ ] Client sends request
    - [ ] Client receives and prints response
    - [ ] Communication works with server
  - Estimated time: 20 minutes
  - Solution: `solutions/04-lesson-4-exercise-3.py`

**Exercise 4.4: Add Error Handling**
- [ ] Task: Modify client to handle timeout
  - Client waits up to 2 seconds for response
  - If timeout: Print error message, don't crash
  - If response: Print battery status
  - Demonstrates: Robustness
  - Success criteria:
    - [ ] Normal case: Response received and printed
    - [ ] Timeout case: Error handled gracefully
    - [ ] No exceptions reach user (caught and handled)
  - Estimated time: 15 minutes
  - Solution: `solutions/04-lesson-4-exercise-4.py`

**Exercise 4.5: Three Roles Service Design**
- [ ] Task: AI-guided service implementation (Layer 2)
  - Scenario: Student implements basic service, AI teaches best practices
  - AI as Teacher: Explains why error handling matters
  - AI as Student: Suggests improvements (timeout, response validation)
  - AI as Co-Worker: Together they converge on robust implementation
  - Success criteria:
    - [ ] Student follows AI Teacher guidance
    - [ ] Student adapts based on feedback (Student role)
    - [ ] Final implementation better than initial (convergence)
  - Estimated time: 20 minutes

### Prerequisites Verification

- [ ] Lessons 1-3 complete
- [ ] Understanding of synchronous vs asynchronous concepts
- [ ] Ability to create and read Python classes

### Success Criteria

- [ ] By end of Lesson 4, students can:
  - [ ] Explain service as synchronous request-response
  - [ ] Write correct .srv file format
  - [ ] Implement service server from scratch
  - [ ] Implement service client from scratch
  - [ ] Handle service timeout with try/except
  - [ ] Distinguish when to use topic vs service

---

## Lesson 5: Quality of Service (QoS) Policies

### Lesson File Creation
- [ ] Create `05-lesson-5.md`
  - Include: QoS concepts (reliability, durability, history), configuration, tradeoffs
  - Narrative: "Quality guarantees" — choosing safety vs speed

### Code Examples

**Example 5.1: Publisher with Custom QoS**
- [ ] Create `temperature_publisher_qos.py` — publisher with configurable QoS
  - Creates: QoSProfile with custom reliability and history settings
  - Demonstrates: RELIABLE vs BEST_EFFORT tradeoff
  - Tests: Verify QoS applied correctly

**Example 5.2: Subscriber with Matching QoS**
- [ ] Create `temperature_subscriber_qos.py` — subscriber with matching QoS
  - Creates: QoSProfile matching publisher
  - Demonstrates: Publisher and subscriber QoS must match
  - Tests: Verify no ROS 2 QoS mismatch warnings

**Example 5.3: Fast Publisher (100 msg/sec)**
- [ ] Create `fast_publisher.py` — publishes 100 messages per second
  - Demonstrates: QoS impact under load
  - Purpose: Show message loss with BEST_EFFORT, no loss with RELIABLE
  - Tests: Run with BEST_EFFORT vs RELIABLE subscribers, count messages

**Example 5.4: QoS Comparison Node**
- [ ] Create `qos_comparison.py` — compares QoS settings side-by-side
  - Creates: Two publishers (one BEST_EFFORT, one RELIABLE)
  - Subscribers: Count messages received from each
  - Output: Comparison table (e.g., "BEST_EFFORT: 42/100 received, RELIABLE: 100/100")

### Diagrams/Visuals

- [ ] Create diagram: "QoS Reliability Tradeoff"
  - BEST_EFFORT: Fast, may drop (sensor data OK)
  - RELIABLE: Safe, slower (critical commands)
  - Show: Speed vs Safety axis

- [ ] Create diagram: "QoS Configuration"
  - Show: QoSProfile parameters (reliability, durability, history, depth)
  - Explain: Each parameter's impact

- [ ] Create table: "QoS Use Cases"
  - Temperature sensor → BEST_EFFORT
  - Emergency stop → RELIABLE
  - Status update → BEST_EFFORT
  - Critical configuration → RELIABLE + TRANSIENT_LOCAL

### Exercises

**Exercise 5.1a: Observe BEST_EFFORT Message Loss**
- [ ] Task: Measure message loss with default QoS
  - Setup: Run fast_publisher.py (100 msg/sec)
  - Run: Subscriber with BEST_EFFORT QoS
  - Count: Messages received (expect ~10-20% loss)
  - Success criteria:
    - [ ] Publisher sends 100 messages
    - [ ] Subscriber receives <90 messages (loss visible)
    - [ ] Student documents result
  - Estimated time: 10 minutes

**Exercise 5.1b: Fix Message Loss with RELIABLE**
- [ ] Task: Switch to RELIABLE and verify no loss
  - Modify: Subscriber to use RELIABLE QoS
  - Modify: Publisher to use RELIABLE QoS (must match)
  - Result: Expect 100/100 messages received
  - Success criteria:
    - [ ] Modified QoS in both publisher and subscriber
    - [ ] All 100 messages received
    - [ ] Student compares before/after
  - Estimated time: 15 minutes

**Exercise 5.2: Configure Custom QoS Profile**
- [ ] Task: Create QoS profile with specific settings
  - Reliability: RELIABLE
  - Durability: VOLATILE (no replay for late subscribers)
  - History: KEEP_LAST 5 (remember last 5 messages)
  - Success criteria:
    - [ ] QoSProfile created with correct parameters
    - [ ] Publisher and subscriber use matching profiles
    - [ ] System works without QoS mismatch warnings
  - Estimated time: 15 minutes
  - Solution: `solutions/05-lesson-5-exercise-2.py`

**Exercise 5.3: QoS Decision Matrix**
- [ ] Task: Document QoS choice for robot system
  - Given: 3 topics (battery, temperature, emergency_stop)
  - Decide: Appropriate QoS for each
  - Justify: Why (safety, latency, cost)
  - Example decisions:
    - [ ] Battery (sensor): BEST_EFFORT (speed, can miss readings)
    - [ ] Temperature (sensor): BEST_EFFORT (speed, can miss readings)
    - [ ] Emergency_stop (command): RELIABLE (safety, must not miss)
  - Success criteria:
    - [ ] Each topic assigned QoS
    - [ ] Justification provided for each choice
    - [ ] Reasoning shows understanding of tradeoffs
  - Estimated time: 15 minutes
  - Solution guide: `solutions/05-lesson-5-exercise-3.md`

**Exercise 5.4: Three Roles QoS Tuning**
- [ ] Task: AI-guided QoS optimization (Layer 2)
  - Scenario: Design QoS for robot health monitor
  - AI as Teacher: Explains QoS policy options
  - AI as Student: Suggests reliability considerations
  - AI as Co-Worker: Together iterate on balanced solution
  - Success criteria:
    - [ ] Student learns QoS concepts from AI
    - [ ] Student suggests practical improvements
    - [ ] Final design balances safety and performance
  - Estimated time: 20 minutes

### Prerequisites Verification

- [ ] Lessons 1-4 complete
- [ ] Working pub/sub implementation from Lessons 1-2
- [ ] Understanding of reliability concept (guaranteed delivery vs best-effort)

### Success Criteria

- [ ] By end of Lesson 5, students can:
  - [ ] Explain Reliability policy (BEST_EFFORT vs RELIABLE)
  - [ ] Explain Durability policy (VOLATILE vs TRANSIENT_LOCAL)
  - [ ] Create custom QoS profile in code
  - [ ] Observe message loss with BEST_EFFORT, fix with RELIABLE
  - [ ] Choose appropriate QoS for given use case
  - [ ] Document reasoning for QoS choices

---

## Lesson 6: Designing Reusable ROS 2 Node Patterns

### Lesson File Creation
- [ ] Create `06-lesson-6.md`
  - Include: Pattern extraction, template design, reusability principles
  - Narrative: "From one-off to reusable" — engineering for reuse

### Code Examples

**Example 6.1: Generic Publisher Template**
- [ ] Create `generic_publisher.py` — parameterized publisher template
  - Parameters: topic_name, message_frequency, message_generator_fn
  - Usage: Instantiate with different functions for temperature, battery, position
  - Demonstrates: Code reuse, abstraction

**Example 6.2: Generic Subscriber Template**
- [ ] Create `generic_subscriber.py` — parameterized subscriber
  - Parameters: topic_name, callback_fn
  - Usage: Instantiate with different callbacks (logging, processing, visualization)
  - Demonstrates: Flexibility through callbacks

**Example 6.3: Temperature Publisher (Using Generic Template)**
- [ ] Create `temperature_publisher_v2.py` — instantiate generic template for temperature
  - Uses: generic_publisher.py as base
  - Configuration: topic="/temperature", frequency=1.0, message_fn=generate_temperature
  - Tests: Verify works exactly like earlier temperature_publisher.py

**Example 6.4: Battery Publisher (Using Generic Template)**
- [ ] Create `battery_publisher_v2.py` — instantiate generic template for battery
  - Uses: generic_publisher.py as base
  - Configuration: topic="/battery", frequency=0.5, message_fn=generate_battery
  - Demonstrates: Same template, different configuration

**Example 6.5: Pub/Sub Decision Tree**
- [ ] Create document: `communication-pattern-guide.md`
  - Decision tree: "Should I use Pub/Sub or Service?"
  - Use cases with examples:
    - [ ] Pub/Sub: Sensor streams, one-way data flow, multiple consumers
    - [ ] Service: Queries, request-response, tight coupling acceptable
  - Decision matrix: Data pattern × Coupling × Timing → Recommendation

### Diagrams/Visuals

- [ ] Create diagram: "Generic Publisher Template"
  - Show: Base template with parameters
  - Show: Instantiations for temperature, battery, position (3 variations)
  - Highlight: Code reuse (same core, different configuration)

- [ ] Create diagram: "Pattern Extraction Process"
  - Lessons 1-5: Multiple similar publisher/subscriber implementations
  - Step 1: Identify common structure (init, callback, publish)
  - Step 2: Identify varying parts (topic, frequency, data)
  - Step 3: Create parameterized template
  - Step 4: Reuse with different parameters

- [ ] Create flowchart: "Communication Pattern Decision Tree"
  - Q1: One-way data flow?
    - Yes → Pub/Sub (Topic)
    - No → Go to Q2
  - Q2: Synchronous response needed?
    - Yes → Service
    - No → Topic (with polling)

### Exercises

**Exercise 6.1a: Extract Generic Publisher Template**
- [ ] Task: Refactor temperature_publisher.py into generic_publisher.py
  - Extract: Common structure (node creation, timer, publish)
  - Parameterize: topic_name, frequency, message_generator_fn
  - Success criteria:
    - [ ] Template created and documented
    - [ ] temperature_publisher_v2.py uses template (one-liner instantiation)
    - [ ] Original functionality preserved
  - Estimated time: 20 minutes
  - Solution: `solutions/06-lesson-6-exercise-1a.py`

**Exercise 6.1b: Instantiate Template for Battery**
- [ ] Task: Create battery_publisher_v2.py using generic template
  - Configuration: Different topic (/battery), frequency (0.5), message_fn
  - Success criteria:
    - [ ] Publisher created with template
    - [ ] Publishes to /battery at 0.5 Hz
    - [ ] Message format correct (battery percentage)
  - Estimated time: 10 minutes
  - Solution: `solutions/06-lesson-6-exercise-1b.py`

**Exercise 6.1c: Instantiate Template for Position**
- [ ] Task: Create position_publisher_v2.py using same template
  - Configuration: /robot/position topic, 2 Hz, position message_fn
  - Success criteria:
    - [ ] Publisher created with template
    - [ ] Publishes to correct topic
    - [ ] All three publishers (temperature, battery, position) use same template
  - Estimated time: 10 minutes
  - Solution: `solutions/06-lesson-6-exercise-1c.py`

**Exercise 6.2a: Extract Generic Subscriber Template**
- [ ] Task: Refactor temperature_subscriber.py into generic_subscriber.py
  - Extract: Common structure (node, subscription, spin)
  - Parameterize: topic_name, callback_fn
  - Success criteria:
    - [ ] Template created
    - [ ] Can create subscriber with generic_subscriber(topic_name, callback)
    - [ ] Works with different callbacks
  - Estimated time: 15 minutes
  - Solution: `solutions/06-lesson-6-exercise-2a.py`

**Exercise 6.2b: Instantiate Subscriber Template (3 variations)**
- [ ] Task: Create 3 subscribers using template (temperature, battery, position)
  - Each with different callback function:
    - [ ] Temperature: log_temperature(msg) — print "Temp: {X}°C"
    - [ ] Battery: log_battery(msg) — print "Battery: {X}%"
    - [ ] Position: log_position(msg) — print "Position: {X}"
  - Success criteria:
    - [ ] All 3 subscribers work with generic template
    - [ ] Each callback prints appropriate formatted output
  - Estimated time: 15 minutes
  - Solution: `solutions/06-lesson-6-exercise-2b.py`

**Exercise 6.3: Pub/Sub vs Service Decision Guide**
- [ ] Task: Create communication pattern decision guide
  - Document: When to use Pub/Sub (topic) vs Service
  - Include: Decision tree, use cases, examples
  - Examples:
    - [ ] Sensor data streaming → Pub/Sub
    - [ ] Robot status query → Service
    - [ ] Real-time navigation commands → Pub/Sub
    - [ ] Configuration request → Service
  - Success criteria:
    - [ ] Decision guide created
    - [ ] At least 4 examples with reasoning
    - [ ] Guide is usable (someone could apply it to new scenario)
  - Estimated time: 20 minutes
  - Solution: `solutions/06-lesson-6-exercise-3.md`

### Prerequisites Verification

- [ ] Lessons 1-5 complete
- [ ] Multiple working publisher and subscriber implementations
- [ ] Understanding of Python parameterization (functions as parameters)

### Success Criteria

- [ ] By end of Lesson 6, students can:
  - [ ] Extract common pattern from multiple implementations
  - [ ] Create parameterized template for publisher
  - [ ] Create parameterized template for subscriber
  - [ ] Reuse templates for 3+ different scenarios
  - [ ] Document decision criteria for Pub/Sub vs Service
  - [ ] Explain benefits of reusable patterns

---

## Lesson 7: Capstone Project — Multi-Node Robot System

### Lesson File Creation
- [ ] Create `07-lesson-7.md`
  - Include: Specification, step-by-step implementation guide, validation procedure
  - Narrative: "Real robot system" — multi-node distributed architecture

### Specification Document

**Robot Status Monitor System (Provided to Students)**
- [ ] Create `capstone-specification.md`
  - Content:
    ```markdown
    ## Robot Status Monitor System Specification

    ### System Intent
    Build robot monitoring system with 3 independent nodes:
    1. Battery Publisher — simulates battery, publishes every 0.5s
    2. Temperature Sensor — simulates motor temperature, publishes every 1s
    3. Status Monitor — subscribes to both, triggers alerts

    ### Constraints
    - Battery warnings at <20% (topic: /robot/battery)
    - Temperature warnings at >60°C (topic: /robot/temperature)
    - Status service query annually (service: /robot/status)
    - All nodes use QoS=RELIABLE

    ### Success Criteria
    [ ] Battery publisher sends correct messages every 0.5s
    [ ] Temperature publisher sends correct messages every 1s
    [ ] Monitor receives all messages (no drops with RELIABLE)
    [ ] Monitor triggers battery warning when <20%
    [ ] Monitor triggers temperature warning when >60°C
    [ ] Status service responds to client queries
    [ ] All 3 nodes work together
    ```

### Code Examples (Solutions)

**Example 7.1: Battery Publisher Node**
- [ ] Create `capstone_battery_publisher.py` — solution code
  - Simulates: Battery declining 100% → 0%
  - Publishes: Integer percentage every 0.5 seconds
  - Topic: `/robot/battery`
  - Tests: Verify publishes at correct frequency

**Example 7.2: Temperature Sensor Node**
- [ ] Create `capstone_temperature_sensor.py` — solution code
  - Simulates: Motor heating 20°C → 80°C
  - Publishes: Float temperature every 1 second
  - Topic: `/robot/temperature`
  - Tests: Verify publishes at correct frequency

**Example 7.3: Status Monitor Node**
- [ ] Create `capstone_status_monitor.py` — solution code
  - Subscribes: Both /robot/battery and /robot/temperature
  - Alerts: Battery <20%, Temperature >60°C
  - Service: Responds to /robot/status queries
  - Tests: Verify alerts triggered at correct thresholds

### Diagrams/Visuals

- [ ] Create diagram: "Capstone System Architecture"
  - Show: 3 nodes (Battery, Temperature, Monitor)
  - Show: Topics (/robot/battery, /robot/temperature)
  - Show: Service (/robot/status)
  - Show: Message flow (publisher → topic → subscriber)

- [ ] Create diagram: "Implementation Steps"
  - Step 1: Read specification
  - Step 2: Create architecture diagram
  - Step 3: Implement battery publisher
  - Step 4: Implement temperature publisher
  - Step 5: Implement status monitor
  - Step 6: Test all nodes together
  - Step 7: Validate against spec

### Exercises

**Exercise 7.1: Specification Comprehension**
- [ ] Task: Read specification, extract requirements
  - Students answer:
    - [ ] What nodes are needed?
    - [ ] What topics are used?
    - [ ] What is the publish frequency?
    - [ ] What are the alert thresholds?
    - [ ] What QoS policy required?
  - Success criteria:
    - [ ] All questions answered correctly
    - [ ] Student creates architecture diagram on paper
    - [ ] Student lists implementation steps in order
  - Estimated time: 20 minutes
  - Checklist provided: `capstone-comprehension-checklist.md`

**Exercise 7.2a: Implement Battery Publisher**
- [ ] Task: Create battery_publisher node from specification
  - Implement: Node that publishes battery 100→0% decay
  - Frequency: 0.5 seconds
  - QoS: RELIABLE
  - Success criteria:
    - [ ] Node starts without error
    - [ ] Publishes to /robot/battery topic
    - [ ] Message format: Integer percentage
    - [ ] Frequency: every 0.5 seconds (verified with ros2 topic hz)
  - Estimated time: 20 minutes
  - Solution: `solutions/capstone-battery-publisher.py`

**Exercise 7.2b: Implement Temperature Sensor**
- [ ] Task: Create temperature_sensor node
  - Implement: Node that publishes motor temperature 20→80°C
  - Frequency: 1 second
  - QoS: RELIABLE
  - Success criteria:
    - [ ] Node starts without error
    - [ ] Publishes to /robot/temperature topic
    - [ ] Message format: Float temperature
    - [ ] Frequency: every 1 second (verified with ros2 topic hz)
  - Estimated time: 20 minutes
  - Solution: `solutions/capstone-temperature-sensor.py`

**Exercise 7.2c: Implement Status Monitor**
- [ ] Task: Create monitor node
  - Implement: Node that subscribes to both topics
  - Alerts: Log warning if battery <20% or temperature >60°C
  - Service: Respond to /robot/status queries with current values
  - Success criteria:
    - [ ] Node subscribes to both topics
    - [ ] Receives all messages from publishers (RELIABLE QoS)
    - [ ] Logs alerts at correct thresholds
    - [ ] Service responds to client queries
    - [ ] No crashes or exceptions
  - Estimated time: 30 minutes
  - Solution: `solutions/capstone-status-monitor.py`

**Exercise 7.3: System Integration Test**
- [ ] Task: Run all 3 nodes together, verify integration
  - Steps:
    - [ ] Terminal 1: Start battery publisher
    - [ ] Terminal 2: Start temperature sensor
    - [ ] Terminal 3: Start status monitor
    - [ ] Terminal 4: Query status service
  - Verify:
    - [ ] All nodes start without error
    - [ ] Monitor receives messages from both publishers
    - [ ] Alerts appear in logs at correct times
    - [ ] Status service responds to queries
    - [ ] System runs for 60 seconds without crashes
  - Success criteria:
    - [ ] All 3 nodes running together
    - [ ] Messages flowing correctly
    - [ ] Alerts triggered as expected
    - [ ] No ROS 2 warnings or errors
  - Estimated time: 20 minutes
  - Debugging guide: `capstone-debugging-guide.md`

**Exercise 7.4: Validation Against Specification**
- [ ] Task: Check system against each success criterion
  - Checklist:
    - [ ] Battery publisher messages every 0.5s? (Use ros2 topic hz)
    - [ ] Temperature publisher messages every 1s? (Use ros2 topic hz)
    - [ ] Monitor receives all messages (0% loss)? (Count messages)
    - [ ] Battery warning at <20%? (Run and observe)
    - [ ] Temperature warning at >60°C? (Run and observe)
    - [ ] Status service responds? (Call service, verify response)
    - [ ] All nodes work together? (Run 60 seconds, no crashes)
  - Success criteria:
    - [ ] All 7 criteria verified
    - [ ] Results documented (screenshot or log)
    - [ ] Student explains any failures
  - Estimated time: 20 minutes
  - Validation checklist: `capstone-validation-checklist.md`

**Exercise 7.5: CLI Tool Inspection**
- [ ] Task: Use ROS 2 CLI to inspect running capstone system
  - Commands:
    - [ ] `ros2 node list` — see all nodes
    - [ ] `ros2 topic list` — see all topics
    - [ ] `ros2 topic info /robot/battery` — see topic details
    - [ ] `ros2 topic echo /robot/battery` — see live messages
    - [ ] `ros2 service list` — see all services
  - Document findings in table:
    - | Command | Output | Interpretation |
      |---------|--------|-----------------|
  - Success criteria:
    - [ ] All commands run successfully
    - [ ] Output correctly interpreted
    - [ ] Shows understanding of system introspection
  - Estimated time: 15 minutes

### Prerequisites Verification

- [ ] All Lessons 1-6 complete
- [ ] Working implementations of:
  - [ ] Node creation and lifecycle
  - [ ] Publisher implementation
  - [ ] Subscriber implementation
  - [ ] Service server and client
  - [ ] QoS configuration
  - [ ] Generic templates from Lesson 6

### Success Criteria

- [ ] By end of Lesson 7 (Capstone), students can:
  - [ ] Read and comprehend ROS 2 system specification
  - [ ] Create architecture diagram from specification
  - [ ] Implement multi-node system independently
  - [ ] Configure nodes to work together
  - [ ] Use CLI tools to verify and debug system
  - [ ] Validate system against specification
  - [ ] Explain design decisions and trade-offs
  - [ ] Run distributed ROS 2 system without support

---

## Cross-Lesson Assessment & Validation

### Overall Chapter Assessment

**Knowledge Check**
- [ ] Create quiz/question set covering Chapter 1 concepts
  - Topics: Node lifecycle, pub/sub pattern, service synchronization, QoS tradeoffs
  - Format: Multiple choice + short answer (test understanding, not memorization)
  - Solution key: `chapter-01-quiz-answers.md`

**Practical Skills Demonstration**
- [ ] Students demonstrate (video or live):
  - [ ] Create and run minimal node
  - [ ] Implement pub/sub pair
  - [ ] Debug with CLI tools
  - [ ] Create and call service
  - [ ] Configure QoS correctly

**Capstone Project Rubric**
- [ ] Create detailed rubric for Lesson 7 capstone:
  - Architecture correctness: Design matches specification
  - Implementation completeness: All nodes created and working
  - QoS compliance: Correct policies applied
  - Error handling: Graceful failure recovery
  - System integration: All nodes work together
  - CLI validation: Student uses tools effectively
  - Documentation: Clear explanation of design

### Content Quality Validation

**Code Example Testing**
- [ ] Every code example in this document must:
  - [ ] Run without errors on clean ROS 2 Humble installation
  - [ ] Produce expected output
  - [ ] Include explanatory comments
  - [ ] Have solution code in `solutions/` directory

**Diagram Verification**
- [ ] Every diagram must:
  - [ ] Be clear and legible
  - [ ] Label all important components
  - [ ] Have a caption explaining what it shows
  - [ ] Be tested with fresh eyes (review by peer)

**Exercise Validation**
- [ ] Every exercise must:
  - [ ] Have clear success criteria (checkboxes)
  - [ ] Be completable in stated time
  - [ ] Have solution provided
  - [ ] Have difficulty level (introduction/practice/challenge)

---

## File Organization Summary

```
specs/book/part-1/
├── chapter-01-plan.md           (This planning document)
├── chapter-01-tasks.md          (This implementation checklist)
└── content/
    ├── 01-lesson-1.md
    ├── 02-lesson-2.md
    ├── 03-lesson-3.md
    ├── 04-lesson-4.md
    ├── 05-lesson-5.md
    ├── 06-lesson-6.md
    ├── 07-lesson-7.md
    ├── diagrams/
    │   ├── node-anatomy.png
    │   ├── node-lifecycle.png
    │   ├── pubsub-pattern.png
    │   ├── message-flow.png
    │   ├── topic-vs-service.png
    │   ├── qos-tradeoff.png
    │   ├── system-architecture.png
    │   └── implementation-steps.png
    ├── code-examples/
    │   ├── 01_minimal_node.py
    │   ├── 02_temperature_publisher.py
    │   ├── 02_temperature_subscriber.py
    │   ├── 03_broken_publisher.py
    │   ├── 04_battery.srv
    │   ├── 04_battery_service_server.py
    │   ├── 04_battery_service_client.py
    │   ├── 05_temperature_publisher_qos.py
    │   ├── 05_fast_publisher.py
    │   ├── 06_generic_publisher.py
    │   ├── 06_generic_subscriber.py
    │   └── 07_capstone_*.py (3 nodes)
    ├── solutions/
    │   ├── 01-lesson-1-exercise-1a.py
    │   ├── 01-lesson-1-exercise-1b.py
    │   ├── 02-lesson-2-exercise-1a.py
    │   └── ... (all exercise solutions)
    ├── checklists/
    │   ├── capstone-comprehension-checklist.md
    │   ├── capstone-validation-checklist.md
    │   └── capstone-debugging-guide.md
    └── references/
        ├── communication-pattern-guide.md
        └── chapter-01-quiz-answers.md
```

---

## Implementation Priority & Timeline

**Phase 1: Foundation (Lessons 1-3)**
- Priority: CRITICAL (blocks later lessons)
- Estimated effort: 40 hours
- Includes: lesson files, code examples, exercises 1-3

**Phase 2: Advanced Concepts (Lessons 4-5)**
- Priority: HIGH (core ROS 2 skills)
- Estimated effort: 30 hours
- Includes: lesson files, code examples, exercises 4-5

**Phase 3: Engineering Practices (Lessons 6-7)**
- Priority: MEDIUM-HIGH (prepares for Part 2)
- Estimated effort: 35 hours
- Includes: lesson files, templates, capstone specification and solution

**Phase 4: Supporting Materials**
- Priority: MEDIUM (enhances learning)
- Estimated effort: 20 hours
- Includes: diagrams, reference guides, quiz

**Total Estimated Effort:** 125 hours

---

## Quality Checklist (Content-Implementer)

Before marking tasks complete:

- [ ] All lesson .md files created and proofread
- [ ] All code examples run successfully (tested)
- [ ] All code examples have explanatory comments
- [ ] All exercises have clear success criteria
- [ ] All exercises have solution code provided
- [ ] All diagrams are clear and labeled
- [ ] All prerequisite verifications are in place
- [ ] Capstone specification is clear and complete
- [ ] All files follow consistent naming convention
- [ ] README created with overview and navigation
- [ ] Content proofread for clarity and correctness
- [ ] Content validated with fresh eyes (peer review)

---

**Document Status:** Ready for content-implementer
**Last Updated:** 2025-12-16
**Next Steps:** Implementation of Lesson 1 content
