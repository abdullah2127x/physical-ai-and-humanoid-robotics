# Chapter 1: ROS 2 Nodes, Topics, and Services — Lesson Plan

**Generated by:** chapter-planner v2.0.0
**Source Spec:** specs/book/part-1-spec.md
**Created:** 2025-12-16
**Constitution:** v6.0.0 (Reasoning-Activated)

---

## I. Chapter Analysis

### Chapter Type
**Technical/Hands-On** — Core ROS 2 architecture requires practical demonstration and exploration. Learning objectives focus on "Apply" level (Bloom's): creating nodes, implementing pub/sub, calling services, debugging with CLI tools.

### Concept Density Analysis

**Core Concepts** (from spec): 6 core concepts
1. Node (independent process performing computation)
2. Topic (named bus for many-to-many messaging)
3. Publisher (node sending messages to topic)
4. Subscriber (node receiving messages from topic)
5. Service (synchronous request-response pattern)
6. QoS (Quality of Service policies controlling reliability vs performance)

**Complexity Assessment:** Standard complexity for robotics beginners
- Concepts are related but distinct (each teaches different communication pattern)
- Familiar pub/sub pattern from software engineering
- Hands-on exercises reinforce abstract concepts
- Cognitive load is manageable with B1 tier

**Proficiency Tier:** B1 (Intermediate Foundation)
- From chapter-index.md: Chapter 01 tier is B1
- Concept cap for B1: 5-7 concepts
- Scaffolding for B1: Heavy guidance, step-by-step walkthrough

**Justified Lesson Count:** 7 lessons
- **Layer 1 (Manual):** 2 lessons — Node fundamentals and topic concepts taught without AI
- **Layer 2 (AI Collaboration):** 3 lessons — Pub/sub and service implementation with AI guidance
- **Layer 3 (Intelligence Design):** 1 lesson — Create reusable ROS 2 node templates/patterns
- **Layer 4 (Spec-Driven):** 1 lesson — Capstone: design multi-node system from specification

**Total:** 7 lessons (justified by 6 core concepts + B1 proficiency + heavy scaffolding requirement)

### Rationale for Lesson Count
- Chapter 1 targets beginners (B1 tier) with heavy scaffolding
- 6 core concepts can be adequately covered in 5 lessons (Layers 1-3)
- 2 additional lessons (Layer 4 capstone) for integration and spec-driven practice
- Heavy scaffolding and hands-on exercises justify 7-lesson depth
- NOT an arbitrary 9-lesson template; specifically sized for concept density + proficiency + pedagogy

---

## II. Success Evals (from Spec)

**Predefined Success Criteria** — Chapter 1 students must demonstrate:

1. **Eval-1.1:** Students can explain ROS 2 architecture (nodes, topics, services) using a diagram → Maps to LO-1.1 (Understand)
2. **Eval-1.2:** Students create and run a ROS 2 node that prints "Hello Robot" independently → Maps to LO-1.2 (Apply)
3. **Eval-1.3:** Students implement a working publisher-subscriber pair that exchanges messages → Maps to LO-1.3 (Apply)
4. **Eval-1.4:** Students create and call a ROS 2 service (server and client) → Maps to LO-1.4 (Apply)
5. **Eval-1.5:** Students modify QoS settings and observe behavior changes → Maps to LO-1.5 (Apply)
6. **Eval-1.6:** Students use ROS 2 CLI tools (ros2 topic, ros2 node, ros2 service) to inspect running systems → Maps to LO-1.6 (Apply)

**All lessons below map to at least one evaluation criterion.**

---

## III. Lesson Sequence

### Lesson 1: Introduction to ROS 2 Nodes (Layer 1: Manual Foundation)

**Learning Objective:** Understand the structure and lifecycle of a ROS 2 node without AI assistance.

**Stage:** 1 (Manual Foundation — No AI yet)

**CEFR Proficiency:** B1

**New Concepts** (count: 3 ≤ 7 limit): ✅ WITHIN LIMIT
1. Node definition and purpose (independent process)
2. Node initialization and lifecycle (create, spin, destroy)
3. Node communication role (sender/receiver placeholder)

**Cognitive Load Validation:** 3 concepts ≤ 7 limit (B1) → ✅ WITHIN LIMIT

**Maps to Evals:** Eval-1.1 (explain architecture understanding)

**Content Elements**

**Opening Narrative (Show-Then-Explain Pattern):**
- Show: Working minimal ROS 2 node printing "Hello Robot" every 1 second
- Code: 15-line Python minimal_node.py (students run it, observe output)
- Challenge: "What parts of this code create the node? What tells it to keep running?"

**Manual Foundation Section:**
- "What is a Node?" — Explain as independent process like a brain neuron
- Metaphor: Human nervous system has neurons; ROS 2 has nodes
- Diagram: Show node as box with input/output connections (topics/services)
- Manual walkthrough: Read node code line-by-line, identify parts
  - `rclpy.init()` → starts ROS 2
  - `Node.__init__()` → defines node class
  - `self.get_logger().info()` → logging without printing
  - `rclpy.spin()` → keeps node alive, processing callbacks
  - `rclpy.shutdown()` → cleanup

**Hands-On Practice:**
- Exercise 1.1a: Create minimal node manually, no copy-paste
  - Students type code from scratch (keyboard emphasis)
  - Incremental building: import → init → class → spin
  - Checkpoint after each step: "Run and check: does node start?"

- Exercise 1.1b: Modify message text and frequency
  - Change "Hello Robot" to "Hello ROS"
  - Change timer from 1.0 to 0.5 seconds
  - Observe behavior change (reinforces causality)

**Prerequisites:** None (first chapter)

**Estimated Time:** 45 minutes

**Success Criteria:**
- [ ] Student can name three parts of ROS 2 node initialization
- [ ] Student can create minimal node from scratch (no reference materials)
- [ ] Student can modify node message and timing independently
- [ ] Student can explain why node "keeps running" (rclpy.spin() concept)

---

### Lesson 2: Topics and Pub/Sub (The Nervous System Pathways) (Layer 1: Manual)

**Learning Objective:** Understand topic-based publish/subscribe pattern and implement manual publisher node.

**Stage:** 1 (Manual Foundation)

**CEFR Proficiency:** B1

**New Concepts** (count: 3 ≤ 7 limit): ✅ WITHIN LIMIT
1. Topic definition (named bus for many-to-many communication)
2. Publisher role and responsibility (sends messages to topic)
3. Message types and data structures (std_msgs, custom structures)

**Cognitive Load Validation:** 3 new concepts ≤ 7 limit → ✅ WITHIN LIMIT

**Maps to Evals:** Eval-1.1 (architecture explanation), Eval-1.3 (pub/sub implementation starts)

**Content Elements**

**Opening Narrative:**
- Show: Publisher node sending temperature data, Subscriber node displaying it
- Students run both nodes, observe communication in action
- Challenge: "How do nodes know how to talk to each other without knowing the other exists?"

**Manual Foundation Section:**
- "What is a Topic?" — Named messaging bus, like a radio frequency
- Metaphor: Nerve pathway carries signals from sensor to brain
- Diagram: Show publisher → topic → subscriber (many-to-many possible)
- Loose Coupling Explanation: Nodes don't need direct addresses, only topic name
- Message Types: Introduce std_msgs (String, Float64, Int32)

**Manual Implementation Walkthrough:**
- Temperature Publisher Node (manual typing):
  - Create publisher: `self.publisher_ = self.create_publisher(String, 'temperature', 10)`
  - Timer callback creates and publishes messages
  - Log each publish for visibility
  - Students trace message from creation to publish

**Hands-On Practice:**
- Exercise 1.2a: Create manual temperature publisher
  - Start with template structure from Lesson 1
  - Add publisher creation
  - Add timer callback with message creation
  - Students type every line (no copy-paste)
  - Run and verify: messages appear in terminal logs

- Exercise 1.2b: Manual subscriber (without ROS CLI tools yet)
  - Create subscriber node
  - Define callback function that fires when message arrives
  - Callback prints: "Received: [temperature]"
  - Challenge: Run publisher and subscriber in separate terminals
  - Observe communication flow

- Exercise 1.2c: Modify message content
  - Publisher sends JSON with timestamp + temperature
  - Subscriber parses and displays formatted output
  - Tests understanding of data structure

**Prerequisites:** Lesson 1 (Node structure knowledge)

**Estimated Time:** 50 minutes

**Success Criteria:**
- [ ] Student can explain topic as "named bus" without reference
- [ ] Student can create publisher manually from scratch
- [ ] Student can create subscriber manually from scratch
- [ ] Student can run publisher and subscriber together and see message flow
- [ ] Student can trace a message from publisher.publish() to subscriber callback

---

### Lesson 3: Debugging Pub/Sub with ROS 2 CLI Tools (Layer 2: AI Collaboration — Teacher Role)

**Learning Objective:** Use ROS 2 CLI tools to inspect and debug running nodes; experience AI as Teacher suggesting debugging strategies.

**Stage:** 2 (AI Collaboration with Three Roles)

**CEFR Proficiency:** B1

**New Concepts** (count: 2 ≤ 7 limit): ✅ WITHIN LIMIT
1. ROS 2 CLI tools (ros2 topic, ros2 node, ros2 echo)
2. System introspection mindset (inspect running systems without code changes)

**Cognitive Load Validation:** 2 new concepts (+ review 6 from Lessons 1-2) ≤ 7 new → ✅ WITHIN LIMIT

**Maps to Evals:** Eval-1.6 (use CLI tools to inspect systems)

**Three Roles Demonstrations** (REQUIRED for Layer 2)

**1. AI as Teacher:**
- **Scenario:** Student has publisher and subscriber running, but no messages appearing. Confused.
- **AI Response:**
  ```
  "I notice your nodes are running separately. Let me teach you how to diagnose this:

  Use 'ros2 topic list' to see all active topics — is 'temperature' there?
  If yes, use 'ros2 topic echo temperature' to see published messages in real-time.
  If no messages appear, use 'ros2 node info /publisher_node_name' to check if
  publisher is actually publishing.

  This debugging sequence (list → echo → node info) follows the pattern:
  Does topic exist? → Are messages flowing? → Is publisher working?"
  ```
- **What Student Learns:** Structured debugging approach; CLI tools are inspection, not just toys

**2. AI as Student:**
- **Scenario:** Student suggests using `ros2 topic hz` to measure message frequency
- **AI Learns:** "Ah, you want to verify publisher is fast enough. Good instinct."
- **AI Adapts:** "For troubleshooting QoS issues later, we'll use exactly this tool."

**3. AI as Co-Worker:**
- **Scenario:** Student and AI iterate on debugging strategy
- **Iteration 1:** Use only `ros2 topic list` — shows topic exists but no info about messages
- **Student Feedback:** "Not enough info. How do I know if messages are actually flowing?"
- **Iteration 2:** Add `ros2 topic echo` to see messages
- **Iteration 3:** Add `ros2 node info` to see node details
- **Convergence:** Together they develop systematic debugging checklist better than either could alone

**Content Elements:**

**Recap Layer 1 Knowledge:**
- Review Lesson 1-2 manual publisher/subscriber code
- Run both nodes together (should work from Lessons 1-2)

**Three Roles Implementation:**
- Scenario A (AI as Teacher): Deliberately break publisher (comment out publish line)
  - Run nodes
  - Use AI guidance to diagnose with CLI tools
  - Student follows AI suggestions step-by-step
  - Student learns: "If topic exists but no messages, publisher code is broken"

- Scenario B (AI as Student): Introduce new diagnostic need
  - Student says: "I want to know if subscriber is too slow"
  - AI suggests: `ros2 topic hz` to check publish rate
  - Both iterate on "is latency the issue?"

- Scenario C (AI as Co-Worker): Joint debugging workflow
  - Create broken system (mixed pub/sub issues)
  - AI and student iterate: list → echo → hz → node info → diagnose
  - Neither could solve alone; together they narrow down root cause

**Hands-On Practice:**

- Exercise 1.3a: Deliberate failure scenarios
  - Publish to wrong topic name (students debug with CLI)
  - Subscriber listens to wrong topic (students use `ros2 topic list` to verify)
  - Publisher crashes, subscriber still runs (students use `ros2 node list` to check)
  - Each scenario reinforces CLI tool use

- Exercise 1.3b: Verify message flow with AI guidance
  - Run publisher + subscriber
  - Use `ros2 topic echo` to confirm messages
  - Use `ros2 topic hz` to confirm frequency
  - Document findings in simple table

**Prerequisites:** Lessons 1-2 (working pub/sub code)

**Estimated Time:** 45 minutes

**Success Criteria:**
- [ ] Student can run `ros2 topic list` and interpret output
- [ ] Student can run `ros2 topic echo` and verify messages
- [ ] Student can run `ros2 node info` and understand output
- [ ] Student can diagnose "topic exists but no messages" using CLI tools
- [ ] Student follows AI guidance to systematically debug (shows Teacher role learning)
- [ ] Student suggests improvements to AI strategy (shows Student role adaptation)

---

### Lesson 4: Services (Synchronous Request-Response) (Layer 2: AI Collaboration)

**Learning Objective:** Understand and implement synchronous request-response pattern using ROS 2 services; collaborate with AI on error handling.

**Stage:** 2 (AI Collaboration with Three Roles)

**CEFR Proficiency:** B1

**New Concepts** (count: 2 ≤ 7 limit): ✅ WITHIN LIMIT
1. Service definition (synchronous request-response, not async like pub/sub)
2. Service client and server roles (sender/receiver in request-response)

**Cognitive Load Validation:** 2 new + 6 previous + 2 from Lesson 3 = 10 concepts total at end, but only 2 NEW this lesson ≤ 7 → ✅ WITHIN LIMIT

**Maps to Evals:** Eval-1.4 (create and call services)

**Three Roles Demonstrations** (REQUIRED)

**1. AI as Teacher:**
- **Scenario:** Student reads service code, confused about why services are different from topics
- **AI Response:**
  ```
  "Good question! Let me teach you the key difference:

  Topics (pub/sub) are asynchronous: publisher sends, subscriber may or may not get it (loose coupling)
  Services are synchronous: client WAITS for response (tight coupling, blocking call)

  Use topics for: sensor streams (temperature reading every second, subscriber doesn't need to ask)
  Use services for: queries (ask 'what's the battery level' and wait for answer)

  The robot example: sensors stream via topics, but robot status queries use services."
  ```
- **What Student Learns:** Conceptual distinction; when to use each pattern

**2. AI as Student:**
- **Scenario:** Student implements service, forgets to handle case where server is offline
- **AI Says:** "Good code structure, but what if the server crashes? Should we retry?"
- **Learns:** "Error handling matters in synchronous calls (but not pub/sub)"

**3. AI as Co-Worker:**
- **Scenario:** Implement battery level service with timeout handling
- **Iteration 1:** Basic service works for happy path
- **Student Feedback:** "What if server doesn't respond for 5 seconds?"
- **Iteration 2:** AI suggests try/except for timeout
- **Iteration 3:** Add timeout parameter to client call
- **Convergence:** Robust service with error handling

**Content Elements:**

**Opening Narrative:**
- Show: Simple service server (battery status) and client (query)
- Run them, observer synchronous request-response
- Challenge: "What's different from Lessons 1-2 pub/sub?"

**Service Concept Explanation:**
- Metaphor: Doorbell analogy (you ring, wait, get answer)
- Contrast with pub/sub (leave message, don't wait)
- Diagram: Client → Service → Response (blocking)

**Manual Implementation (with AI guidance):**
- Service definition: Understand .srv files (Request/Response structure)
- Service server implementation: Define callback that computes response
- Service client implementation: Call service and wait for response
- Error handling: Try/except for timeouts and exceptions

**Three Roles Walkthrough:**

- Scenario A (AI as Teacher): Implement battery status service
  - AI teaches: service .srv format, server callback structure
  - Student implements step-by-step

- Scenario B (AI as Student): Add timeout handling
  - Student observes: "Server sometimes slow"
  - AI learns: Need timeout
  - Student implements with AI guidance

- Scenario C (AI as Co-Worker): Iterate on response format
  - Basic response: just battery percentage
  - Iteration 1: Add status message ("charging" / "discharging")
  - Iteration 2: Add timestamp
  - Convergence: Rich, useful response

**Hands-On Practice:**

- Exercise 1.4a: Implement battery status service
  - Create service definition: Battery.srv (request: empty, response: percentage)
  - Implement server that computes battery % (simulate with random)
  - Implement client that calls service and prints response
  - Run both, verify response received

- Exercise 1.4b: Error handling with AI collaboration
  - Student implements basic version
  - AI suggests: "Add timeout in case server slow"
  - Student adds timeout parameter
  - Student intentionally delays server response, tests timeout

- Exercise 1.4c: Complex service response
  - Service response includes: battery %, status (charging/discharging), time
  - Student implements parser on client side
  - Tests robustness with various server responses

**Prerequisites:** Lessons 1-3 (node and pub/sub understanding)

**Estimated Time:** 50 minutes

**Success Criteria:**
- [ ] Student can explain service as "synchronous request-response"
- [ ] Student can create service definition (.srv file) manually
- [ ] Student can implement service server from scratch
- [ ] Student can implement service client from scratch
- [ ] Student can add try/except error handling for timeouts
- [ ] Student can distinguish when to use topic vs service (explaining reasoning)

---

### Lesson 5: Quality of Service (QoS) Policies (Layer 2: AI Collaboration)

**Learning Objective:** Understand and configure QoS settings; trade reliability for performance with AI guidance on best practices.

**Stage:** 2 (AI Collaboration)

**CEFR Proficiency:** B1

**New Concepts** (count: 1 ≤ 7 limit): ✅ WITHIN LIMIT
1. QoS policies (reliability, durability, history depth) controlling message delivery guarantees

**Cognitive Load Validation:** 1 new concept (review others) ≤ 7 → ✅ WITHIN LIMIT

**Maps to Evals:** Eval-1.5 (modify QoS and observe behavior changes)

**Three Roles Demonstrations** (REQUIRED)

**1. AI as Teacher:**
- **Scenario:** Student's subscriber is missing some messages from fast publisher
- **AI Response:**
  ```
  "I notice your subscriber has QoS Reliability=BEST_EFFORT (default).
  This means: if publisher too fast, subscriber drops messages.

  Let me teach you QoS settings:
  - Reliability: BEST_EFFORT (fast, may drop) vs RELIABLE (guaranteed, slower)
  - Durability: VOLATILE (only live subscribers) vs TRANSIENT_LOCAL (replay for new subscribers)
  - History: KEEP_LAST N messages vs KEEP_ALL

  For sensor streams (temperature), BEST_EFFORT is OK.
  For critical commands, use RELIABLE."
  ```

**2. AI as Student:**
- **Scenario:** Student sets all QoS to RELIABLE and TRANSIENT_LOCAL
- **AI Notes:** "That works, but is slow. Can we balance safety and performance?"
- **Learns:** Trade-off thinking

**3. AI as Co-Worker:**
- **Scenario:** Design QoS for robot health monitor
- **Iteration 1:** RELIABLE (safe but slow)
- **Student Feedback:** "Messages arrive too late to respond"
- **Iteration 2:** Switch to BEST_EFFORT (fast but drops)
- **Student Feedback:** "Missing critical warnings"
- **Iteration 3:** Compromise — RELIABLE but with history=1 (keep latest only)
- **Convergence:** Balanced solution

**Content Elements:**

**Opening Narrative:**
- Show: Publisher sending 100 messages/sec
- Default subscriber misses most (BEST_EFFORT default)
- Challenge: "Why are we missing messages even though publisher works?"

**QoS Concepts:**
- Reliability Policy:
  - BEST_EFFORT: publisher sends, subscriber gets if listening (may drop if slow)
  - RELIABLE: publisher waits for acknowledgement (guaranteed but slower)
- Durability Policy:
  - VOLATILE: messages only for subscribed listeners
  - TRANSIENT_LOCAL: new subscribers get recent messages (for startup)
- History Policy:
  - KEEP_LAST N: remember last N messages
  - KEEP_ALL: remember every message (memory risk)

**Three Roles QoS Tuning:**

- Scenario A (AI as Teacher): Diagnose missing messages
  - Student observes: missing messages
  - AI teaches: QoS reliability is culprit
  - Student changes: BEST_EFFORT → RELIABLE
  - All messages now received

- Scenario B (AI as Student): Discuss latency tradeoff
  - Student complains: "RELIABLE is too slow"
  - AI suggests: "Trade-off. Can we accept dropping some?"
  - Student decides: sensor data OK to drop, commands must be reliable

- Scenario C (AI as Co-Worker): Configure per-topic QoS
  - Temperature topic: BEST_EFFORT (OK to miss)
  - Emergency stop topic: RELIABLE (never drop)
  - Together they configure system with appropriate QoS per topic

**Hands-On Practice:**

- Exercise 1.5a: Observe QoS impact
  - Run publisher with 100 msg/sec
  - Subscriber with BEST_EFFORT (default) — count received messages (expect ~10-20% loss)
  - Switch subscriber to RELIABLE — count received messages (expect 100%)
  - Document difference in results

- Exercise 1.5b: Configure QoS manually
  - Create publisher with QoS policy setting:
    ```python
    qos_policy = QoSProfile(
        reliability=QoSReliabilityPolicy.RELIABLE,
        durability=QoSDurabilityPolicy.TRANSIENT_LOCAL,
        history=QoSHistoryPolicy.KEEP_LAST,
        depth=5
    )
    self.publisher_ = self.create_publisher(String, 'topic', qos_policy)
    ```
  - Create subscriber with matching QoS
  - Test behavior

- Exercise 1.5c: QoS mismatch detection
  - Create publisher with RELIABLE
  - Create subscriber with BEST_EFFORT
  - Observe ROS 2 warning about QoS mismatch
  - Fix by matching QoS policies
  - Document lesson: "Publisher and subscriber must agree on QoS"

**Prerequisites:** Lessons 1-4 (working pub/sub and services)

**Estimated Time:** 40 minutes

**Success Criteria:**
- [ ] Student can explain Reliability policy (BEST_EFFORT vs RELIABLE)
- [ ] Student can explain when to use each policy (trade-offs)
- [ ] Student can implement custom QoS policy in code
- [ ] Student can observe message loss with BEST_EFFORT and fix with RELIABLE
- [ ] Student can document QoS tradeoffs for a robot scenario

---

### Lesson 6: Designing Reusable ROS 2 Node Patterns (Layer 3: Intelligence Design)

**Learning Objective:** Create reusable node templates and patterns encapsulating Lessons 1-5 knowledge; design components for reuse.

**Stage:** 3 (Intelligence Design)

**CEFR Proficiency:** B1

**Reusable Artifacts Created:**
- Template 1: Generic Publisher Node (configurable topic, message type, frequency)
- Template 2: Generic Subscriber Node (configurable topic, callback behavior)
- Pattern Document: "When to use Pub/Sub vs Services"

**Maps to Evals:** All evals (synthesizes Lessons 1-5)

**Content Elements:**

**Intelligence Design Pattern:**

Step 1: Analyze Lessons 1-5 patterns
- All lessons created different publishers/subscribers/services
- Common structure repeated: init, callback, publish/subscribe
- Opportunity: Extract common structure into reusable template

Step 2: Design generic publisher template
- Template accepts: topic name, message type, publish frequency, callback logic
- Abstract: What changes per use case? (topic, frequency, data)
- Abstract: What stays same? (ROS 2 initialization, timer callback pattern)

Step 3: Design generic subscriber template
- Template accepts: topic name, message type, callback function
- Abstract: What changes? (topic name, callback logic)
- Abstract: What stays same? (init, subscription creation, spin)

Step 4: Create pattern document
- Decision tree: "Choosing Pub/Sub vs Service"
  - If one-directional streaming → Pub/Sub + Topic
  - If request-response needed → Service
  - If multiple conditions → Decision table

**Hands-On Practice:**

- Exercise 1.6a: Create generic publisher template
  - Students extract from Lessons 1-2 code
  - Template has parameters: topic_name, message_content_fn, frequency_hz
  - Test template by instantiating 3 different publishers (temperature, battery, position)
  - All publishers work with same template code

- Exercise 1.6b: Create generic subscriber template
  - Students extract from Lesson 2 code
  - Template has parameters: topic_name, callback_fn
  - Test by subscribing to all 3 topics created in 1.6a
  - Verify all messages received

- Exercise 1.6c: Create "Pub/Sub vs Service" decision template
  - Document when to use each pattern with concrete examples
  - Robot scenario decision tree: which communication for each interaction?
  - Students justify choices using Layer 3 reasoning

**Prerequisites:** Lessons 1-5 (accumulated knowledge to encapsulate)

**Estimated Time:** 50 minutes

**Success Criteria:**
- [ ] Student can create generic publisher template (parameterized by topic)
- [ ] Student can reuse publisher template for 3 different use cases
- [ ] Student can create generic subscriber template (parameterized by callback)
- [ ] Student can document decision criteria for Pub/Sub vs Service
- [ ] Student can explain reusable patterns from Lessons 1-5

---

### Lesson 7: Capstone Project — Multi-Node Robot System (Layer 4: Spec-Driven Integration)

**Learning Objective:** Design and implement a multi-node robotic system from specification; compose accumulated skills; practice spec-driven development.

**Stage:** 4 (Spec-Driven Integration)

**CEFR Proficiency:** B1

**Maps to Evals:** ALL evals integrated (comprehensive assessment)

**Content Elements:**

**Specification-First Approach (PRIMARY):**

Students receive specification and write code to satisfy it:

```markdown
## Robot Status Monitor System Specification

### System Intent
Build a distributed robot monitoring system with 3 independent nodes:
1. Battery Publisher - simulates robot battery, publishes every 0.5s
2. Temperature Sensor - simulates motor temperature, publishes every 1s
3. Status Monitor - subscribes to both, triggers alerts if thresholds exceeded

### Constraints
- Battery warnings trigger at <20% (topic: /robot/battery)
- Temperature warnings trigger at >60C (topic: /robot/temperature)
- Monitor must poll status service annually (service: /robot/status)
- All nodes must implement QoS=RELIABLE

### Success Criteria
1. Battery publisher sends correct messages every 0.5s
2. Temperature publisher sends correct messages every 1s
3. Monitor receives all messages (no drops with RELIABLE QoS)
4. Monitor correctly detects warning thresholds and logs alerts
5. All 3 nodes work together as integrated system
```

**Spec-Driven Development Workflow:**

1. **Read Specification** (not code yet)
   - Students identify: nodes needed, topics, services, QoS requirements
   - Students plan architecture on paper before coding

2. **Design Before Code** (architecture phase)
   - Draw diagram: 3 boxes (nodes), arrows (topics), service call
   - List required: message types, topic names, QoS policies
   - Identify: which Lessons 1-5 patterns apply?

3. **Implement According to Spec** (code phase)
   - Create Battery Publisher node (uses Lesson 1-2 patterns + QoS from Lesson 5)
   - Create Temperature Sensor node (pub/sub pattern)
   - Create Status Monitor node (subscriber to both topics + service client from Lesson 4)
   - Implement error handling (timeout in service call)

4. **Validate Against Specification** (testing phase)
   - Run all 3 nodes together
   - Check each success criterion:
     - [ ] Battery message frequency correct?
     - [ ] Temperature message frequency correct?
     - [ ] Monitor receives all messages (RELIABLE QoS)?
     - [ ] Alerts triggered at correct thresholds?
     - [ ] All nodes work together?
   - Document validation results

**Integration Points (Compose Lessons 1-6):**

- Lesson 1 pattern: Node initialization and lifecycle
- Lesson 2 pattern: Publisher and subscriber implementation
- Lesson 3 pattern: Use ros2 CLI tools to debug multi-node system
- Lesson 4 pattern: Service implementation for status queries
- Lesson 5 pattern: QoS configuration for reliability
- Lesson 6 pattern: Reusable node templates (use generic publisher from L6)

**Hands-On Practice:**

- Exercise 1.7a: Specification comprehension
  - Read provided spec
  - Extract: nodes needed, topics, services, constraints
  - Create architecture diagram
  - List implementation steps before coding

- Exercise 1.7b: Implementation
  - Create Battery Publisher (simulates battery 100% → 0% decay)
  - Create Temperature Sensor (simulates motor heating)
  - Create Status Monitor (subscribes + services)
  - Each node independent; compose into system

- Exercise 1.7c: Validation and debugging
  - Run full system
  - Use ros2 CLI tools (Lesson 3) to verify topics, nodes, services
  - Troubleshoot issues (intentional bugs in spec)
  - Document final working system

**Prerequisites:** Lessons 1-6 (all core concepts and reusable patterns)

**Estimated Time:** 90 minutes

**Success Criteria:**
- [ ] Student writes architecture diagram before code
- [ ] Student creates 3 nodes implementing spec correctly
- [ ] Student configures QoS=RELIABLE per spec
- [ ] Student implements service call with timeout handling
- [ ] All 3 nodes run together without crashes
- [ ] All success criteria in spec are satisfied
- [ ] Student uses CLI tools to validate system
- [ ] Student documents what worked and challenges encountered

---

## IV. Skill Dependencies

**Skill Dependency Graph:**
```
Lesson 1: Node Fundamentals
    ↓
Lesson 2: Publisher/Subscriber
    ↓
Lesson 3: CLI Tools (inspects pub/sub)
    ├─→ Lesson 4: Services (independent of 3)
    ├─→ Lesson 5: QoS (extends 2, independent of 3-4)
    ↓
Lesson 6: Reusable Patterns (synthesizes 1-5)
    ↓
Lesson 7: Capstone (integrates all, spec-driven)
```

**Justification:**
- Lesson 1 prerequisite for all others (node concept)
- Lesson 2 prerequisite for Lesson 3 (CLI tools inspect topics)
- Lesson 4 independent of Lesson 3 (services don't use topics)
- Lesson 5 builds on Lesson 2 (QoS affects pub/sub)
- Lesson 6 requires Lessons 1-5 (encapsulation)
- Lesson 7 requires Lessons 1-6 (integration)

**Cross-Chapter Dependencies:**
- Chapter 1 has no prerequisites (first chapter)
- Chapter 2 requires Chapter 1 (ROS 2 fundamentals assumed)
- Chapter 3 requires Chapters 1-2 (node and pub/sub knowledge used)

---

## V. Assessment Plan

### Formative Assessments (During Lessons)

| Lesson | Assessment Type | Success Criteria |
|--------|-----------------|------------------|
| 1 | Create minimal node | Node prints message, student can modify timing |
| 2 | Create pub/sub pair | Messages flow between publisher and subscriber |
| 3 | Debugging scenario | Student uses CLI tools to diagnose broken pub/sub |
| 4 | Implement service | Service server responds to client requests |
| 5 | Configure QoS | Student modifies policies and observes impact |
| 6 | Create templates | Generic publisher/subscriber work for 3 scenarios |
| 7 | Capstone system | All 3 nodes work together, satisfy spec |

### Summative Assessment (End of Chapter)

**Lesson 7 Capstone Project:**
- Multi-node system implementation from specification
- Grading rubric:
  - [ ] Architecture correctness (nodes, topics, services designed per spec)
  - [ ] Implementation completeness (all 3 nodes created and working)
  - [ ] QoS compliance (correct policies applied)
  - [ ] Error handling (services have timeout handling)
  - [ ] System integration (all nodes work together)
  - [ ] CLI validation (student uses tools to verify)
  - [ ] Documentation (student explains design and validation)

**All assessments align with CEFR B1 + Bloom's Apply level** (students apply concepts to new scenarios)

---

## VI. Validation Checklist

**Chapter-Level Validation:**
- [x] Chapter type identified: Technical/Hands-On
- [x] Concept density: 6 core concepts, justified for B1 proficiency
- [x] Lesson count: 7 lessons justified (not arbitrary template)
- [x] All evals from spec covered by lessons
- [x] All lessons map to at least one eval

**Stage Progression Validation:**
- [x] Lessons 1-2: Layer 1 (Manual, no AI)
- [x] Lessons 3-5: Layer 2 (AI Collaboration with Three Roles demonstrated)
- [x] Lesson 6: Layer 3 (Intelligence Design, reusable patterns)
- [x] Lesson 7: Layer 4 (Spec-Driven Integration)
- [x] No spec-first before Layer 4

**Cognitive Load Validation:**
- [x] Lesson 1: 3 concepts ≤ 7 limit
- [x] Lesson 2: 3 concepts ≤ 7 limit
- [x] Lesson 3: 2 concepts ≤ 7 limit
- [x] Lesson 4: 2 concepts ≤ 7 limit
- [x] Lesson 5: 1 concept ≤ 7 limit
- [x] Lesson 6: Synthesis, not new concepts
- [x] Lesson 7: Integration, not new concepts

**Dependency Validation:**
- [x] Lesson order satisfies skill prerequisites (1→2→3/4/5→6→7)
- [x] Cross-chapter dependency: None (Chapter 1 is first)
- [x] All Lesson 1-5 concepts support Lessons 6-7

**Three Roles Validation (Layer 2):**
- [x] Lesson 3: AI as Teacher (debugging guidance), Student (adapts CLI use), Co-Worker (convergence on checklist)
- [x] Lesson 4: AI as Teacher (service distinction), Student (error handling), Co-Worker (timeout handling)
- [x] Lesson 5: AI as Teacher (QoS concepts), Student (tradeoff learning), Co-Worker (per-topic QoS)

**Canonical Sources:**
- Follows ROS 2 official documentation patterns for rclpy usage
- CLI commands (ros2 topic, ros2 node, ros2 service) standard ROS 2 tools

---

## VII. Risks & Mitigations

| Risk | Impact | Mitigation |
|------|--------|------------|
| ROS 2 installation issues | Blocks all progress | Provide Docker container with ROS 2 pre-installed |
| async/await confusion (Layer 2) | Slows Lessons 3-5 | Focus on callbacks; explain async later in Part 2 |
| QoS mismatch errors (Lesson 5) | Frustrates learners | Provide QoS checker script; clear error messages |
| Capstone integration complexity | Overwhelms students | Provide architecture template; scaffold implementation |

---

**Summary:** Chapter 1 teaches 6 core ROS 2 concepts (nodes, topics, publishers, subscribers, services, QoS) across 7 lessons, progressing through all 4 teaching layers. Heavy scaffolding appropriate for B1 beginners. Spec-driven capstone integrates all learning into practical multi-node system.
