# Chapter 2: Bridging Python Agents to ROS Controllers (rclpy) — Lesson Plan

**Generated by:** chapter-planner v2.0.0
**Source Spec:** specs/book/part-1-spec.md
**Created:** 2025-12-16
**Constitution:** v6.0.0 (Reasoning-Activated)

---

## I. Chapter Analysis

### Chapter Type
**Technical/Hands-On with Integration Focus** — Builds directly on Chapter 1 ROS 2 fundamentals. Learning objectives emphasize "Apply" level: structuring Python packages, implementing async patterns, creating action clients, defining custom messages, building Python agents that control robots.

### Concept Density Analysis

**Core Concepts** (from spec): 6 core concepts
1. rclpy (ROS 2 Python client library)
2. Action (long-running asynchronous task with feedback)
3. Message Type (data structure defining communication protocol)
4. Callback (event-driven function)
5. Executor (manages callback execution and concurrency)
6. Package (unit of ROS 2 code organization)

**Complexity Assessment:** Standard complexity, builds on Chapter 1 foundation
- Concepts are related but distinct
- Async/await patterns add complexity (but built on callbacks from Chapter 1)
- Hands-on exercises with real Python patterns reinforce concepts
- Cognitive load manageable with B1 tier proficiency

**Proficiency Tier:** B1 (Intermediate Foundation)
- From chapter-index.md: Chapter 02 tier is B1
- Concept cap for B1: 5-7 concepts
- Scaffolding for B1: Heavy guidance, step-by-step walkthrough
- Note: 6 core concepts right at B1 capacity

**Justified Lesson Count:** 7 lessons
- **Layer 1 (Manual):** 2 lessons — Package structure and async fundamentals taught without AI
- **Layer 2 (AI Collaboration):** 3 lessons — Actions, messages, callbacks with AI guidance
- **Layer 3 (Intelligence Design):** 1 lesson — Create reusable action client patterns
- **Layer 4 (Spec-Driven):** 1 lesson — Build Python agent controlling robot from specification

**Total:** 7 lessons (justified by 6 core concepts + B1 proficiency + integration complexity)

### Rationale for Lesson Count
- Chapter 2 builds on Chapter 1 (assumes nodes, pub/sub, services known)
- 6 core concepts can be adequately covered in 5 lessons (Layers 1-3)
- Integration focus justifies additional lesson (Layer 4 capstone)
- Heavy scaffolding required for async/await (begins Lesson 2)
- Action client pattern introduces complexity (full lesson justified)
- NOT an arbitrary 9-lesson template; specifically sized for concept density + proficiency + integration focus

---

## II. Success Evals (from Spec)

**Predefined Success Criteria** — Chapter 2 students must demonstrate:

1. **Eval-2.1:** Students structure ROS 2 Python packages correctly → Maps to LO-2.1 (Apply)
2. **Eval-2.2:** Students implement async/await patterns without blocking callbacks → Maps to LO-2.2 (Apply)
3. **Eval-2.3:** Students create action clients for long-running tasks with feedback → Maps to LO-2.3 (Apply)
4. **Eval-2.4:** Students define and use custom message types → Maps to LO-2.4 (Apply)
5. **Eval-2.5:** Students build Python agent making autonomous robot decisions → Maps to LO-2.5 (Apply)
6. **Eval-2.6:** Students explain executor models (single vs multi-threaded) → Maps to LO-2.6 (Understand)

**All lessons below map to at least one evaluation criterion.**

---

## III. Lesson Sequence

### Lesson 1: ROS 2 Python Package Structure (Layer 1: Manual Foundation)

**Learning Objective:** Understand and manually create proper ROS 2 Python package structure without AI assistance.

**Stage:** 1 (Manual Foundation — No AI)

**CEFR Proficiency:** B1

**New Concepts** (count: 2 ≤ 7 limit): ✅ WITHIN LIMIT
1. Package definition (unit of ROS 2 code organization)
2. Package.xml and setup.py files (metadata and build configuration)

**Cognitive Load Validation:** 2 concepts ≤ 7 limit (B1) → ✅ WITHIN LIMIT

**Maps to Evals:** Eval-2.1 (structure ROS 2 packages correctly)

**Content Elements**

**Opening Narrative (Show-Then-Explain):**
- Show: Working ROS 2 Python package with proper structure
- Show: Running colcon build successfully
- Challenge: "How is this different from a regular Python project?"

**Manual Foundation Section:**
- "What is a Package?" — Container for ROS 2 code, metadata, executables
- Metaphor: Library that can be shared, versioned, and integrated
- Package components:
  - `src/` directory (Python source code)
  - `package.xml` (metadata: name, version, dependencies)
  - `setup.py` (Python build configuration)
  - `setup.cfg` (build tool configuration)

**Manual Walkthrough:**
- Directory structure explanation
  - Why `src/` subdirectory? (Python packaging convention)
  - Why `package.xml`? (ROS 2 dependency resolution)
  - Why `setup.py`? (Python entry points, scripts)
- File-by-file explanation:
  - `package.xml`: version, description, maintainer, dependency list
  - `setup.py`: package name, version, entry_points (where executables live)
  - `__init__.py`: Python package marker (required)

**Hands-On Practice:**

- Exercise 2.1a: Create package structure manually
  - No `ros2 pkg create` command (students do it by hand to understand)
  - Create: directories, files (package.xml, setup.py, __init__.py)
  - Type each file from scratch (keyboard emphasis)
  - Checkpoint: Verify structure with `tree` command

- Exercise 2.1b: Build package with colcon
  - Run: `colcon build`
  - Observe: Successful build output
  - Verify: Package appears in install/

- Exercise 2.1c: Understand package.xml dependencies
  - Modify: package.xml to add rclpy dependency
  - Explain: How ROS 2 resolves dependencies
  - Practice: Identify required vs optional dependencies

**Prerequisites:** Chapter 1 completed (nodes, pub/sub, services)

**Estimated Time:** 45 minutes

**Success Criteria:**
- [ ] Student can create package directory structure manually
- [ ] Student can write valid package.xml from scratch
- [ ] Student can write basic setup.py with entry points
- [ ] Student can run colcon build successfully
- [ ] Student can explain purpose of each file

---

### Lesson 2: Async/Await and Callbacks (The Non-Blocking Node) (Layer 1: Manual)

**Learning Objective:** Understand event-driven callback architecture and manual async implementation in Python without AI assistance.

**Stage:** 1 (Manual Foundation)

**CEFR Proficiency:** B1

**New Concepts** (count: 2 ≤ 7 limit): ✅ WITHIN LIMIT
1. Callback pattern (function triggered by event, not explicitly called)
2. async/await syntax (cooperative multitasking, non-blocking execution)

**Cognitive Load Validation:** 2 new concepts ≤ 7 limit → ✅ WITHIN LIMIT

**Maps to Evals:** Eval-2.2 (implement async/await patterns without blocking)

**Content Elements**

**Opening Narrative:**
- Show: Node with fast timer (100 Hz) and slow subscriber callback (takes 1 second)
- Default ROS 2: Timer blocks on slow callback (only ~1 message/sec, not 100)
- Challenge: "How can we have both execute independently?"

**Callback Concept Explanation:**
- "What is a Callback?" — Function registered to fire when event happens
- ROS 2 events: Timer fires, Message arrives, Service request
- Manual walkthrough: Event → trigger callback → callback executes → continue

**Async/Await Manual Implementation:**
- Contrast: Blocking vs non-blocking
  - Blocking: `time.sleep(1)` — thread halts for 1 second
  - Non-blocking: `await asyncio.sleep(1)` — yields to other tasks
- Single vs Multiple Tasks:
  - Single task: Run one after another (blocking)
  - Multiple tasks: Interleave execution (non-blocking)
- Executor role: Manages multiple concurrent callbacks

**Manual Coding Practice:**

- Exercise 2.2a: Compare blocking vs non-blocking
  - Code A: Node with slow callback (1 second processing) on 10 Hz timer
    - Result: Only ~1 message processed per second (blocking)
  - Code B: Node with async callback (non-blocking sleep)
    - Result: All 10 messages per second processed (non-blocking)
  - Students type both, observe difference
  - Key learning: async allows parallelism in single-threaded context

- Exercise 2.2b: Implement node with timer + subscriber (non-blocking)
  - Timer callback: Print timestamp every 0.5 seconds
  - Subscriber callback: Process message (1-second processing)
  - Requirement: Both execute independently (async)
  - Students implement with `await asyncio.sleep()`
  - Verify: Messages received while timer also fires

**Prerequisites:** Lesson 2.1 (package structure), Chapter 1 (nodes, callbacks)

**Estimated Time:** 50 minutes

**Success Criteria:**
- [ ] Student can explain callback as "event-triggered function"
- [ ] Student can implement basic callback without blocking
- [ ] Student can distinguish blocking (time.sleep) vs non-blocking (await)
- [ ] Student can run timer + subscriber concurrently
- [ ] Student can trace execution order of async callbacks

---

### Lesson 3: Action Clients for Long-Running Tasks (Layer 2: AI Collaboration)

**Learning Objective:** Understand action pattern for long-running tasks with feedback; implement action client with AI guidance on state management.

**Stage:** 2 (AI Collaboration with Three Roles)

**CEFR Proficiency:** B1

**New Concepts** (count: 1 ≤ 7 limit): ✅ WITHIN LIMIT
1. Action (long-running task with feedback loop: goal → feedback → result)

**Cognitive Load Validation:** 1 new + 6 previous = 7 concepts total, but only 1 NEW ≤ 7 → ✅ WITHIN LIMIT

**Maps to Evals:** Eval-2.3 (create action clients for long-running tasks)

**Three Roles Demonstrations** (REQUIRED for Layer 2)

**1. AI as Teacher:**
- **Scenario:** Student confused why service doesn't work for robot arm movement (takes 10 seconds)
- **AI Response:**
  ```
  "Great question! Services are synchronous and complete in <1 second.
  But arm movement takes 10 seconds. That's why we use Actions.

  Actions have three stages:
  1. Client sends goal (move arm to position)
  2. Server executes, sends feedback periodically (progress: 50% done)
  3. Server sends final result (movement complete)

  Services: Goal → Result (too abrupt)
  Actions: Goal → Feedback → Feedback → Result (progress visibility)"
  ```
- **What Student Learns:** Action pattern differs from service for long-running tasks

**2. AI as Student:**
- **Scenario:** Student implements basic action client, no feedback handling
- **AI Suggests:** "Could we monitor progress to show user status?"
- **Learns:** Feedback is valuable (not just waiting for result)

**3. AI as Co-Worker:**
- **Scenario:** Implement robust action client with timeout
- **Iteration 1:** Basic client calls goal, waits for result
- **Student Feedback:** "What if server crashes mid-movement?"
- **Iteration 2:** Add timeout exception handling
- **Iteration 3:** Add feedback processing (log progress)
- **Convergence:** Robust client with error handling + progress visibility

**Content Elements:**

**Opening Narrative:**
- Show: Simple service (works great for battery query)
- Show: Action for arm movement (10 seconds) — why service won't work
- Demonstrate: Action feedback showing progress

**Action Concept Explanation:**
- Action as Extension of Service:
  - Service: Fast request-response
  - Action: Long-running with progress feedback
- Action Components:
  - Goal: What to do? (move arm to position)
  - Feedback: Progress? (50% done)
  - Result: What happened? (success/failure)

**Manual Action Implementation (with AI guidance):**

- Action definition: Understand .action file (Goal/Feedback/Result)
- Action server: Implement executor that processes goal, sends feedback, returns result
- Action client: Send goal, wait for result, monitor feedback
- State management: Handle feedback callbacks during execution

**Three Roles Walkthrough:**

- Scenario A (AI as Teacher): Teach action pattern vs service
  - AI explains when to use action (long-running, feedback needed)
  - Student implements basic action client

- Scenario B (AI as Student): Suggest feedback monitoring
  - Student builds client without feedback handling
  - AI proposes: "Log progress updates"
  - Student adds feedback callback

- Scenario C (AI as Co-Worker): Robust implementation
  - Iterate: Basic → timeout handling → progress logging → error recovery
  - Convergence: Professional-grade action client

**Hands-On Practice:**

- Exercise 2.3a: Create action definition (.action file)
  - Define MoveArm action: Goal (position), Feedback (progress %), Result (success)
  - Success criteria:
    - [ ] .action file format correct
    - [ ] Fields have appropriate types
    - [ ] Readable by ROS 2 build system

- Exercise 2.3b: Implement action server
  - Server executes goal (simulated arm movement)
  - Sends feedback every 1 second (progress: 0%, 25%, 50%, 75%, 100%)
  - Returns result: Success or failure
  - Success criteria:
    - [ ] Server runs without error
    - [ ] Feedback sent during execution
    - [ ] Result returned correctly

- Exercise 2.3c: Implement action client
  - Client sends goal (move arm)
  - Client receives feedback and logs: "Progress: 50%"
  - Client waits for result
  - Success criteria:
    - [ ] Client connects to server
    - [ ] Goal sent successfully
    - [ ] Feedback received and logged
    - [ ] Result received and verified

- Exercise 2.3d: Add error handling with AI guidance
  - Extend client: Add timeout exception handling
  - Extend server: Simulate occasional failures
  - Client gracefully handles failures
  - Success criteria:
    - [ ] Timeout detected and handled
    - [ ] Client doesn't crash on failure
    - [ ] Error messages informative

**Prerequisites:** Lessons 2.1-2.2 (package, async), Chapter 1 (services)

**Estimated Time:** 50 minutes

**Success Criteria:**
- [ ] Student can create .action file with Goal/Feedback/Result
- [ ] Student can implement action server from scratch
- [ ] Student can implement action client from scratch
- [ ] Student can receive and log feedback during action execution
- [ ] Student can add timeout error handling
- [ ] Student can distinguish when to use Service vs Action

---

### Lesson 4: Custom Message Types (Layer 2: AI Collaboration)

**Learning Objective:** Define custom message types that extend standard messages; implement pub/sub with custom types using AI guidance.

**Stage:** 2 (AI Collaboration with Three Roles)

**CEFR Proficiency:** B1

**New Concepts** (count: 1 ≤ 7 limit): ✅ WITHIN LIMIT
1. Custom message type (user-defined data structure for communication)

**Cognitive Load Validation:** 1 new + previous ≤ 7 → ✅ WITHIN LIMIT

**Maps to Evals:** Eval-2.4 (define and use custom message types)

**Three Roles Demonstrations** (REQUIRED)

**1. AI as Teacher:**
- **Scenario:** Student tries to send robot arm status (battery + temperature + position)
- **Problem:** std_msgs.String isn't enough; need structured data
- **AI Response:**
  ```
  "I see you need to send multiple fields.
  std_msgs only have single fields (String, Int32, Float64).

  Let me teach you custom messages!
  Create RobotStatus.msg with fields:
    - battery_percent (int32)
    - temperature_celsius (float32)
    - position_x (float32)
    - position_y (float32)
    - position_z (float32)

  Now you can publish rich structured data!"
  ```
- **What Student Learns:** Custom messages solve data structure problems

**2. AI as Student:**
- **Scenario:** Student defines RobotStatus with 10 fields
- **AI Suggests:** "Do we really need all 10? Could we group position into separate message?"
- **Learns:** Message design trade-offs (simplicity vs comprehensiveness)

**3. AI as Co-Worker:**
- **Scenario:** Design RobotStatus message with good structure
- **Iteration 1:** Flat structure (10 fields in one message)
- **Student Feedback:** "Hard to understand, too many fields"
- **Iteration 2:** Restructure (basic fields + nested Position message)
- **Iteration 3:** Refine field names for clarity
- **Convergence:** Clean, maintainable message design

**Content Elements:**

**Opening Narrative:**
- Show: Standard message (String) inadequate for robot data
- Show: Custom message (RobotStatus) with multiple fields
- Challenge: "How do we define new message types?"

**Custom Message Concept:**
- .msg file format: Field definitions (type + name)
- Nested messages: One message type containing another
- Message generation: ROS 2 builds Python/C++ classes from .msg

**Manual Implementation (with AI guidance):**

- Message definition: Create .msg file with fields
- Build system: Understand how ROS 2 generates message classes
- Publisher: Use custom message type in pub/sub
- Subscriber: Parse custom message fields

**Three Roles Walkthrough:**

- Scenario A (AI as Teacher): Teach message design
  - AI explains .msg format
  - Student creates RobotStatus.msg

- Scenario B (AI as Student): Suggest improvements
  - Student defines basic message
  - AI proposes: "Could we nest Position as separate message?"
  - Student refactors

- Scenario C (AI as Co-Worker): Iterate on design
  - Basic → structured → well-named → final design

**Hands-On Practice:**

- Exercise 2.4a: Create custom message type
  - Create RobotStatus.msg with fields:
    - battery_percent: int32
    - temperature_celsius: float32
    - arm_position_x: float32
    - arm_position_y: float32
  - Success criteria:
    - [ ] .msg file created with correct format
    - [ ] Build system accepts it (colcon build)
    - [ ] ROS 2 generates Python class
    - [ ] Can import: from my_package.msg import RobotStatus

- Exercise 2.4b: Publish custom message type
  - Create publisher that sends RobotStatus
  - Populate fields with simulated data
  - Publish every 1 second
  - Success criteria:
    - [ ] Publisher compiles without error
    - [ ] Messages published successfully
    - [ ] Message fields contain correct values

- Exercise 2.4c: Subscribe to custom message
  - Create subscriber to RobotStatus topic
  - Callback receives message, extracts and prints each field
  - Output: "Battery: 85%, Temp: 45C, Position: (1.0, 2.0)"
  - Success criteria:
    - [ ] Subscriber compiles and runs
    - [ ] All message fields accessible
    - [ ] Output formatted clearly

- Exercise 2.4d: Message design with AI guidance
  - Scenario: Design RobotArm message (joint angles + gripper state)
  - AI as Teacher: Explains nested message design
  - AI as Student: Suggests field names
  - AI as Co-Worker: Refine structure together
  - Success criteria:
    - [ ] Message design complete
    - [ ] Nested structure (if applicable)
    - [ ] Field names meaningful
    - [ ] Builds and compiles successfully

**Prerequisites:** Lessons 2.1-2.3 (package, async, actions), Chapter 1 (pub/sub)

**Estimated Time:** 45 minutes

**Success Criteria:**
- [ ] Student can create .msg file from scratch
- [ ] Student can define message with multiple fields
- [ ] Student can publish custom message type
- [ ] Student can subscribe and parse custom message
- [ ] Student can design appropriate message structure for scenario

---

### Lesson 5: Executors and Concurrency (Layer 2: AI Collaboration)

**Learning Objective:** Understand executor models (single vs multi-threaded) and their impact on callback execution; choose appropriate executor for scenario with AI guidance.

**Stage:** 2 (AI Collaboration)

**CEFR Proficiency:** B1

**New Concepts** (count: 1 ≤ 7 limit): ✅ WITHIN LIMIT
1. Executor (manages callback execution model: single-threaded vs multi-threaded)

**Cognitive Load Validation:** 1 new + previous ≤ 7 → ✅ WITHIN LIMIT

**Maps to Evals:** Eval-2.6 (explain executor models and tradeoffs)

**Three Roles Demonstrations** (REQUIRED)

**1. AI as Teacher:**
- **Scenario:** Student runs node with slow subscriber callback (5 seconds) and fast timer
- **Problem:** Timer blocked by slow callback; doesn't fire on time
- **AI Response:**
  ```
  "I see the issue! You're using single-threaded executor (default).
  It processes callbacks sequentially: slow callback blocks timer.

  Two executor options:
  1. SingleThreadedExecutor (default): Sequential callbacks (blocking)
  2. MultiThreadedExecutor: Parallel callbacks (concurrent)

  For your case (fast timer + slow callback), use MultiThreadedExecutor.
  But careful: parallel execution needs thread-safe code!"
  ```
- **What Student Learns:** Executor choice impacts concurrency behavior

**2. AI as Student:**
- **Scenario:** Student switches to MultiThreadedExecutor without considering thread safety
- **AI Notes:** "Parallel execution is great, but now we have race conditions. Need locks?"
- **Learns:** Thread-safety trade-offs with parallelism

**3. AI as Co-Worker:**
- **Scenario:** Choose executor for robot arm controller
- **Iteration 1:** Use SingleThreadedExecutor (simple but blocking)
- **Student Feedback:** "Arm movements are delayed while processing sensor data"
- **Iteration 2:** Switch to MultiThreadedExecutor for parallelism
- **Iteration 3:** Add mutex/lock for shared state
- **Convergence:** Responsive concurrent controller

**Content Elements:**

**Opening Narrative:**
- Show: Single-threaded node where slow callback blocks timer
- Show: Multi-threaded node where callbacks execute in parallel
- Challenge: "Why would we choose one over the other?"

**Executor Concept:**
- SingleThreadedExecutor: Process callbacks one-at-a-time (blocking)
  - Pros: Simple, no concurrency issues, predictable
  - Cons: Blocking, slow callback affects entire node
- MultiThreadedExecutor: Process callbacks in parallel
  - Pros: Responsive, non-blocking
  - Cons: Complex, needs thread-safe code, race conditions

**Manual Implementation:**

- SingleThreadedExecutor (default):
  ```python
  executor = SingleThreadedExecutor()
  executor.add_node(node)
  executor.spin()
  ```

- MultiThreadedExecutor:
  ```python
  executor = MultiThreadedExecutor(num_threads=2)
  executor.add_node(node)
  executor.spin()
  ```

**Thread Safety Concepts:**
- Shared state: Variables modified by multiple threads
- Race condition: Two threads modify same variable simultaneously
- Mutex/Lock: Protect shared state from concurrent access

**Three Roles Walkthrough:**

- Scenario A (AI as Teacher): Teach executor models
  - AI explains sequential vs parallel execution
  - Student observes impact on node responsiveness

- Scenario B (AI as Student): Suggest parallelism
  - Student wants fast timer + slow callback
  - AI suggests MultiThreadedExecutor
  - Student implements

- Scenario C (AI as Co-Worker): Iterate on executor choice
  - Start single-threaded (simple)
  - Observe blocking behavior
  - Switch to multi-threaded
  - Add thread safety as needed
  - Convergence: Responsive, safe concurrent system

**Hands-On Practice:**

- Exercise 2.5a: Observe single-threaded blocking
  - Create node with: timer (0.5s) + slow subscriber (5s processing)
  - Use SingleThreadedExecutor (default)
  - Observe: Timer doesn't fire while subscriber processing
  - Document: Blocking behavior
  - Success criteria:
    - [ ] Node runs without error
    - [ ] Blocking behavior visible
    - [ ] Student understands why

- Exercise 2.5b: Switch to multi-threaded executor
  - Modify: Use MultiThreadedExecutor instead
  - Observe: Timer fires even during slow subscriber
  - Compare: Behavior change from Exercise 2.5a
  - Success criteria:
    - [ ] Executor changed to MultiThreadedExecutor
    - [ ] Concurrent execution visible
    - [ ] No crashes or race conditions (simple shared state)

- Exercise 2.5c: Identify race condition
  - Create node with shared counter (incremented by multiple callbacks)
  - Use MultiThreadedExecutor
  - Count final value (expect race condition: lower than expected)
  - Success criteria:
    - [ ] Race condition observed
    - [ ] Student understands why counter is wrong
    - [ ] Student can explain concurrency issue

- Exercise 2.5d: Fix race condition with lock
  - Modify: Add mutex/threading.Lock around shared state
  - Verify: Counter now correct with MultiThreadedExecutor
  - Success criteria:
    - [ ] Lock implemented correctly
    - [ ] Counter value accurate
    - [ ] No deadlocks or exceptions

- Exercise 2.5e: Choose executor for scenario (AI guidance)
  - Scenario: Robot arm controller with:
    - Fast arm movements (0.1s feedback)
    - Slow sensor processing (2s analysis)
    - Shared state: arm position
  - Decision: Which executor? Why?
  - AI guidance: Suggests MultiThreadedExecutor + mutex
  - Implementation: Student implements with guidance
  - Success criteria:
    - [ ] Correct executor chosen
    - [ ] Reasoning documented
    - [ ] Thread safety ensured

**Prerequisites:** Lessons 2.1-2.2 (package, async)

**Estimated Time:** 50 minutes

**Success Criteria:**
- [ ] Student can explain SingleThreadedExecutor (sequential callbacks)
- [ ] Student can explain MultiThreadedExecutor (parallel callbacks)
- [ ] Student can observe blocking behavior in single-threaded
- [ ] Student can identify race condition with shared state
- [ ] Student can use mutex/lock for thread safety
- [ ] Student can choose appropriate executor for scenario

---

### Lesson 6: Building Reusable ROS 2 Python Patterns (Layer 3: Intelligence Design)

**Learning Objective:** Encapsulate Lessons 2.1-2.5 patterns into reusable components; design action client templates and message definitions for reuse.

**Stage:** 3 (Intelligence Design)

**CEFR Proficiency:** B1

**Reusable Artifacts Created:**
- Template 1: Generic Action Client (configurable action type, goal, feedback handling)
- Template 2: Async Node Base Class (reusable async node structure)
- Pattern Document: "When to use Message vs Service vs Action"

**Maps to Evals:** All evals (synthesizes Lessons 2.1-2.5)

**Content Elements:**

**Intelligence Design Pattern:**

Step 1: Analyze Lessons 2.1-2.5 patterns
- Package structure repeated across lessons
- Action client pattern repeated for different action types
- Async callback pattern repeated
- Opportunity: Extract common structure into reusable templates

Step 2: Design generic action client template
- Template accepts: action type, goal parameters, feedback handler
- Abstract: What changes? (action type, specific parameters)
- Abstract: What stays same? (client creation, goal sending, result handling)

Step 3: Design async node base class
- Template accepts: node name, callbacks to register
- Provides: Async callback infrastructure, MultiThreadedExecutor setup
- Reduces boilerplate for future async nodes

Step 4: Create decision guide
- "Message vs Service vs Action" decision tree
  - Simple one-way data → Topic + Message
  - Request-response, fast → Service
  - Request-response, long-running → Action

**Hands-On Practice:**

- Exercise 2.6a: Create generic action client template
  - Extract from Lesson 2.3 action client code
  - Template has parameters: action_type, action_namespace, goal_params
  - Test template by instantiating 3 different action clients
  - Success criteria:
    - [ ] Template created and parameterized
    - [ ] 3 different action clients work with same template
    - [ ] Code reuse visible (DRY principle)

- Exercise 2.6b: Create async node base class
  - Extract from Lessons 2.1-2.2 async node patterns
  - Base class provides: async callback registration, executor setup
  - Subclasses: Minimal code to define node-specific callbacks
  - Success criteria:
    - [ ] Base class created with async infrastructure
    - [ ] Subclasses simple and focused
    - [ ] Reduces boilerplate significantly

- Exercise 2.6c: Create communication pattern guide
  - Document: Decision tree for Message/Service/Action
  - Include: 5+ robot scenarios with pattern recommendations
  - Example decisions:
    - [ ] Publish sensor stream (temperature 100x/sec) → Topic + Message
    - [ ] Query robot battery → Service
    - [ ] Move arm to position (takes 10s with feedback) → Action
  - Success criteria:
    - [ ] Decision guide complete and usable
    - [ ] Reasoning documented for each choice

**Prerequisites:** Lessons 2.1-2.5 (accumulated knowledge to encapsulate)

**Estimated Time:** 50 minutes

**Success Criteria:**
- [ ] Student can create generic action client template
- [ ] Student can reuse template for 3 different action types
- [ ] Student can create async node base class
- [ ] Student can create Message/Service/Action decision guide
- [ ] Student can explain benefits of reusable patterns

---

### Lesson 7: Capstone Project — Python Agent Controlling Robot (Layer 4: Spec-Driven Integration)

**Learning Objective:** Build autonomous Python agent that makes decisions and controls simulated robot from specification; integrate all Chapter 2 concepts.

**Stage:** 4 (Spec-Driven Integration)

**CEFR Proficiency:** B1

**Maps to Evals:** ALL evals integrated (comprehensive assessment)

**Content Elements:**

**Specification-First Approach (PRIMARY):**

Students receive specification and write code to satisfy it:

```markdown
## Robot Arm Controller Agent Specification

### System Intent
Build autonomous Python agent that:
1. Monitors arm sensor (temperature, position)
2. Decides movement based on decision logic
3. Commands arm movement via action server
4. Reports status via pub/sub

### Constraints
- Sensor topic: /arm/sensor_data (custom RobotSensorData message)
- Movement action: /move_arm (accepts goal position)
- Status publisher: /arm/status (custom ArmStatus message)
- Decision logic: Move if temp <50°C, else stop for cooling
- All async, non-blocking callbacks
- MultiThreadedExecutor for responsiveness

### Success Criteria
1. Agent subscribes to sensor data
2. Agent publishes status updates (every 1s)
3. Agent sends move commands when conditions met
4. Agent monitors feedback from arm movements
5. All nodes/agents work together
6. No blocking, fully async implementation
```

**Spec-Driven Development Workflow:**

1. **Read Specification** (not code yet)
   - Students identify: components needed, messages, actions, decision logic
   - Students plan architecture before coding

2. **Design Before Code** (architecture phase)
   - Diagram: Agent node, sensor subscriber, status publisher, move action client
   - List: Custom messages (RobotSensorData, ArmStatus)
   - Identify: Which Lessons 2.1-2.6 patterns apply

3. **Implement According to Spec** (code phase)
   - Create custom messages (RobotSensorData, ArmStatus)
   - Create sensor simulator node (publishes sensor data)
   - Create arm action server (simulates arm movement)
   - Create agent node (subscribes, decides, commands)
   - All with proper package structure, async callbacks

4. **Validate Against Specification** (testing phase)
   - Run all nodes together
   - Check each success criterion
   - Document validation results

**Integration Points (Compose Lessons 2.1-2.6):**

- Lesson 2.1 pattern: Package structure with proper setup.py
- Lesson 2.2 pattern: Async callbacks (timer + subscriber non-blocking)
- Lesson 2.3 pattern: Action client for movement commands
- Lesson 2.4 pattern: Custom message types for structured communication
- Lesson 2.5 pattern: MultiThreadedExecutor for responsiveness
- Lesson 2.6 pattern: Reusable components (use generic action client from L6)

**Hands-On Practice:**

- Exercise 2.7a: Specification comprehension
  - Read provided spec
  - Extract: nodes/agents needed, messages, actions, decision logic
  - Create architecture diagram
  - List implementation steps
  - Success criteria:
    - [ ] All requirements understood
    - [ ] Architecture diagram complete
    - [ ] Implementation plan clear

- Exercise 2.7b: Define custom message types
  - Create RobotSensorData.msg (temperature, position)
  - Create ArmStatus.msg (current_position, is_moving, last_command)
  - Success criteria:
    - [ ] Both .msg files created and valid
    - [ ] Build system accepts them
    - [ ] Can import from agent code

- Exercise 2.7c: Implement sensor simulator
  - Create node that publishes RobotSensorData
  - Simulates: Temperature varying, position changing
  - Frequency: 10 Hz
  - Success criteria:
    - [ ] Node runs without error
    - [ ] Publishes to correct topic
    - [ ] Message fields populated correctly

- Exercise 2.7d: Implement arm action server
  - Create action server accepting movement goals
  - Server simulates arm movement (takes 5 seconds)
  - Sends feedback every 1 second (progress: 0%, 25%, 50%, 75%, 100%)
  - Success criteria:
    - [ ] Action server runs
    - [ ] Feedback sent during movement
    - [ ] Result returned on completion

- Exercise 2.7e: Implement agent decision logic
  - Agent subscribes to sensor data
  - Decision: If temp <50°C, send move goal; else wait
  - Agent publishes status with current decision
  - Success criteria:
    - [ ] Agent subscribes to sensor data
    - [ ] Decision logic correct (temp threshold)
    - [ ] Move goals sent when appropriate
    - [ ] Status published every 1s

- Exercise 2.7f: System integration test
  - Run all 4 nodes/agents together
  - Verify: Sensor data flows, agent makes decisions, arm moves
  - Verify: Async callbacks non-blocking (all run concurrently)
  - Success criteria:
    - [ ] All nodes start without error
    - [ ] Messages and actions flow correctly
    - [ ] Agent responds within 1 second to sensor data
    - [ ] System runs without crashes

- Exercise 2.7g: Validation and documentation
  - Check each specification criterion
  - Document findings (screenshots/logs)
  - Explain design decisions
  - Success criteria:
    - [ ] All spec criteria satisfied
    - [ ] Documentation complete

**Prerequisites:** Lessons 2.1-2.6 (all core concepts and reusable patterns)

**Estimated Time:** 90 minutes

**Success Criteria:**
- [ ] Student understands specification completely
- [ ] Student creates architecture diagram before coding
- [ ] Student implements proper package structure
- [ ] Student defines and uses custom messages
- [ ] Student implements async non-blocking agent
- [ ] Student uses action client for robot control
- [ ] Student uses MultiThreadedExecutor for responsiveness
- [ ] Full multi-node system works without crashes

---

## IV. Skill Dependencies

**Skill Dependency Graph:**
```
Lesson 2.1: Package Structure
    ↓
Lesson 2.2: Async/Callbacks
    ├─→ Lesson 2.3: Action Clients
    ├─→ Lesson 2.4: Custom Messages
    ├─→ Lesson 2.5: Executors
    ↓
Lesson 2.6: Reusable Patterns (synthesizes 2.1-2.5)
    ↓
Lesson 2.7: Capstone (integrates all)
```

**Justification:**
- Lesson 2.1 prerequisite for all (package structure)
- Lesson 2.2 prerequisite for advanced concepts (async foundation)
- Lessons 2.3-2.5 can be parallel after 2.2 (independent concepts)
- Lesson 2.6 requires 2.1-2.5 (encapsulation)
- Lesson 2.7 requires all (integration)

**Cross-Chapter Dependencies:**
- Chapter 2 requires Chapter 1 (nodes, pub/sub, services)
- Chapter 3 uses some Chapter 2 patterns (rclpy, Python packages)

---

## V. Assessment Plan

### Formative Assessments (During Lessons)

| Lesson | Assessment Type | Success Criteria |
|--------|-----------------|------------------|
| 2.1 | Create package structure | colcon build succeeds, proper files present |
| 2.2 | Async implementation | Timer and subscriber execute concurrently |
| 2.3 | Action client | Client sends goal, receives feedback and result |
| 2.4 | Custom message | Define, publish, subscribe with custom type |
| 2.5 | Executor choice | Identify blocking behavior, fix with MultiThreadedExecutor |
| 2.6 | Pattern templates | Generic action client works for 3+ scenarios |
| 2.7 | Capstone integration | All nodes work together, spec criteria satisfied |

### Summative Assessment (End of Chapter)

**Lesson 2.7 Capstone Project:**
- Multi-agent system implementing specification
- Grading rubric:
  - [ ] Package structure correct (proper files, dependencies)
  - [ ] Custom messages well-designed (appropriate fields, types)
  - [ ] Async implementation non-blocking (concurrent execution)
  - [ ] Action client robust (handles feedback, errors)
  - [ ] Agent decision logic correct (proper conditions)
  - [ ] System integration (all nodes work together)
  - [ ] Documentation complete (design decisions explained)

**All assessments align with CEFR B1 + Bloom's Apply level** (apply concepts to new scenarios)

---

## VI. Validation Checklist

**Chapter-Level Validation:**
- [x] Chapter type identified: Technical/Hands-On with Integration
- [x] Concept density: 6 core concepts, justified for B1 proficiency
- [x] Lesson count: 7 lessons justified (not arbitrary template)
- [x] All evals from spec covered by lessons
- [x] All lessons map to at least one eval

**Stage Progression Validation:**
- [x] Lessons 2.1-2.2: Layer 1 (Manual, no AI)
- [x] Lessons 2.3-2.5: Layer 2 (AI Collaboration with Three Roles demonstrated)
- [x] Lesson 2.6: Layer 3 (Intelligence Design, reusable patterns)
- [x] Lesson 2.7: Layer 4 (Spec-Driven Integration)
- [x] No spec-first before Layer 4

**Cognitive Load Validation:**
- [x] Lesson 2.1: 2 concepts ≤ 7 limit
- [x] Lesson 2.2: 2 concepts ≤ 7 limit
- [x] Lesson 2.3: 1 concept ≤ 7 limit
- [x] Lesson 2.4: 1 concept ≤ 7 limit
- [x] Lesson 2.5: 1 concept ≤ 7 limit
- [x] Lesson 2.6: Synthesis, not new concepts
- [x] Lesson 2.7: Integration, not new concepts

**Dependency Validation:**
- [x] Lesson order satisfies prerequisites
- [x] Cross-chapter dependency: Chapter 1 required (assumed complete)
- [x] All Lesson 2.1-2.5 concepts support Lessons 2.6-2.7

**Three Roles Validation (Layer 2):**
- [x] Lesson 2.3: AI as Teacher (action pattern), Student (feedback importance), Co-Worker (robustness)
- [x] Lesson 2.4: AI as Teacher (custom messages), Student (design refinement), Co-Worker (message design)
- [x] Lesson 2.5: AI as Teacher (executor models), Student (thread safety), Co-Worker (executor choice)

---

## VII. Risks & Mitigations

| Risk | Impact | Mitigation |
|------|--------|------------|
| async/await confusion | Slows Lesson 2.2 | Use simple examples; sync alternatives shown first |
| Package structure complexity | Overwhelms beginners | Provide templates; step-by-step scaffolding |
| Custom message build errors | Frustrates students | Provide message checker; clear error messages |
| Race conditions (Lesson 2.5) | Crashes on shared state | Use simple examples; introduce threading gradually |
| Capstone integration | System too complex | Provide node templates; scaffold implementation |

---

**Summary:** Chapter 2 teaches 6 core rclpy concepts (rclpy client library, actions, messages, callbacks, executors, packages) across 7 lessons, progressing through all 4 teaching layers. Heavy scaffolding appropriate for B1 learners building on Chapter 1 foundation. Spec-driven capstone integrates all learning into autonomous agent controlling simulated robot.
